// ### [ Helper productions ] ##################################################

// ___ [ Function Attribute ] __________________________________________________

// ref: ParseFnAttributeValuePairs
//
//   ::= <attr> | <attr> '=' <value>

FuncAttrs
	: empty
	<< ([]ll.FuncAttribute)(nil), nil >>
	| FuncAttrList
;

FuncAttrList
	: FuncAttr
	<< []ll.FuncAttribute{$0.(ll.FuncAttribute)}, nil >>
	| FuncAttrList FuncAttr
	<< append($0.([]ll.FuncAttribute), $1.(ll.FuncAttribute)), nil >>
;

FuncAttr
	// not used in attribute groups.
	: AttrGroupID
	// used in attribute groups.
	| "align" "=" int_lit               << &ll.Alignment{Align: astx.Int($2)}, nil >>
	| "alignstack" "=" int_lit          << &ll.StackAlignment{Align: astx.Int($2)}, nil >>
	// used in functions.
	| Alignment
	| AllocSize
	| StackAlignment
	| StringLit                         << &ll.FuncAttrString{Value: $0.(string)}, nil >>
	| StringLit "=" StringLit           << &ll.FuncAttrPair{Key: $0.(string), Value: $2.(string)}, nil >>
	| "alwaysinline"                    << ll.FuncAttrAlwaysInline, nil >>
	| "argmemonly"                      << ll.FuncAttrArgMemOnly, nil >>
	| "builtin"                         << ll.FuncAttrBuiltin, nil >>
	| "cold"                            << ll.FuncAttrCold, nil >>
	| "convergent"                      << ll.FuncAttrConvergent, nil >>
	| "inaccessiblemem_or_argmemonly"   << ll.FuncAttrInaccessibleMemOrArgMemOnly, nil >>
	| "inaccessiblememonly"             << ll.FuncAttrInaccessibleMemOnly, nil >>
	| "inlinehint"                      << ll.FuncAttrInlineHint, nil >>
	| "jumptable"                       << ll.FuncAttrJumpTable, nil >>
	| "minsize"                         << ll.FuncAttrMinSize, nil >>
	| "naked"                           << ll.FuncAttrNaked, nil >>
	| "nobuiltin"                       << ll.FuncAttrNoBuiltin, nil >>
	| "noduplicate"                     << ll.FuncAttrNoDuplicate, nil >>
	| "noimplicitfloat"                 << ll.FuncAttrNoImplicitFloat, nil >>
	| "noinline"                        << ll.FuncAttrNoInline, nil >>
	| "nonlazybind"                     << ll.FuncAttrNonLazyBind, nil >>
	| "norecurse"                       << ll.FuncAttrNoRecurse, nil >>
	| "noredzone"                       << ll.FuncAttrNoRedZone, nil >>
	| "noreturn"                        << ll.FuncAttrNoReturn, nil >>
	| "nounwind"                        << ll.FuncAttrNoUnwind, nil >>
	| "optnone"                         << ll.FuncAttrOptNone, nil >>
	| "optsize"                         << ll.FuncAttrOptSize, nil >>
	| "readnone"                        << ll.FuncAttrReadNone, nil >>
	| "readonly"                        << ll.FuncAttrReadOnly, nil >>
	| "returns_twice"                   << ll.FuncAttrReturnsTwice, nil >>
	| "safestack"                       << ll.FuncAttrSafeStack, nil >>
	| "sanitize_address"                << ll.FuncAttrSanitizeAddress, nil >>
	| "sanitize_hwaddress"              << ll.FuncAttrSanitizeHWAddress, nil >>
	| "sanitize_memory"                 << ll.FuncAttrSanitizeMemory, nil >>
	| "sanitize_thread"                 << ll.FuncAttrSanitizeThread, nil >>
	| "speculatable"                    << ll.FuncAttrSpeculatable, nil >>
	| "ssp"                             << ll.FuncAttrSSP, nil >>
	| "sspreq"                          << ll.FuncAttrSSPReq, nil >>
	| "sspstrong"                       << ll.FuncAttrSSPStrong, nil >>
	| "strictfp"                        << ll.FuncAttrStrictFP, nil >>
	| "uwtable"                         << ll.FuncAttrUwtable, nil >>
	| "writeonly"                       << ll.FuncAttrWriteOnly, nil >>
;

// ___ [ Return Attribute ] __________________________________________________

// ref: ParseOptionalReturnAttrs

ReturnAttrs
	: empty
	<< ([]ll.ReturnAttribute)(nil), nil >>
	| ReturnAttrList
;

ReturnAttrList
	: ReturnAttr
	<< []ll.ReturnAttribute{$0.(ll.ReturnAttribute)}, nil >>
	| ReturnAttrList ReturnAttr
	<< append($0.([]ll.ReturnAttribute), $1.(ll.ReturnAttribute)), nil >>
;

ReturnAttr
	: Alignment
	| Dereferenceable
	| StringLit         << &ll.ReturnAttrString{Value: $0.(string)}, nil >>
	| "inreg"           << ll.ReturnAttrInReg, nil >>
	| "noalias"         << ll.ReturnAttrNoAlias, nil >>
	| "nonnull"         << ll.ReturnAttrNonNull, nil >>
	| "signext"         << ll.ReturnAttrSignExt, nil >>
	| "zeroext"         << ll.ReturnAttrZeroExt, nil >>
;

// ___ [ Parameter Attribute ] _________________________________________________

// ref: ParseOptionalParamAttrs

ParamAttrs
	: empty
	<< ([]ll.ParamAttribute)(nil), nil >>
	| ParamAttrList
;

ParamAttrList
	: ParamAttr
	<< []ll.ParamAttribute{$0.(ll.ParamAttribute)}, nil >>
	| ParamAttrList ParamAttr
	<< append($0.([]ll.ParamAttribute), $1.(ll.ParamAttribute)), nil >>
;

// ref: ParseOptionalDerefAttrBytes
//
//   ::= empty
//   ::= AttrKind '(' 4 ')'

ParamAttr
	: Alignment
	| Dereferenceable
	| StringLit         << &ll.ParamAttrString{Value: $0.(string)}, nil >>
	| "byval"           << ll.ParamAttrByval, nil >>
	| "inalloca"        << ll.ParamAttrInAlloca, nil >>
	| "inreg"           << ll.ParamAttrInReg, nil >>
	| "nest"            << ll.ParamAttrNest, nil >>
	| "noalias"         << ll.ParamAttrNoAlias, nil >>
	| "nocapture"       << ll.ParamAttrNoCapture, nil >>
	| "nonnull"         << ll.ParamAttrNonNull, nil >>
	| "readnone"        << ll.ParamAttrReadNone, nil >>
	| "readonly"        << ll.ParamAttrReadOnly, nil >>
	| "returned"        << ll.ParamAttrReturned, nil >>
	| "signext"         << ll.ParamAttrSignExt, nil >>
	| "sret"            << ll.ParamAttrSRet, nil >>
	| "swifterror"      << ll.ParamAttrSwiftError, nil >>
	| "swiftself"       << ll.ParamAttrSwiftSelf, nil >>
	| "writeonly"       << ll.ParamAttrWriteOnly, nil >>
	| "zeroext"         << ll.ParamAttrZeroExt, nil >>
;

// ___ [ Attributes ] __________________________________________________________

// ref: ParseOptionalAddrSpace
//
//   := empty
//   := 'addrspace' '(' uint32 ')'

OptAddrSpace
	: empty
	<< types.AddrSpace(0), nil >>
	| AddrSpace
;

AddrSpace
	: "addrspace" "(" int_lit ")"
	<< types.AddrSpace(astx.Int($2)), nil >>
;

// ref: ParseOptionalAlignment
//
//   ::= empty
//   ::= 'align' 4

Alignment
	: "align" int_lit
	<< &ll.Alignment{Align: astx.Int($1)}, nil >>
;

// ref: parseAllocSizeArguments

AllocSize
	: "allocsize" "(" int_lit ")"
	<< &ll.AllocSize{BaseSize: astx.Int($2)}, nil >>
	| "allocsize" "(" int_lit "," int_lit ")"
	<< &ll.AllocSize{BaseSize: astx.Int($2), N: astx.Int($4)}, nil >>
;

// ref: parseOptionalComdat

OptComdat
	: empty
	<< (*ll.Comdat)(nil), nil >>
	| Comdat
;

Comdat
	: "comdat"
	<< &ll.Comdat{}, nil >>
	| "comdat" "(" ComdatName ")"
	<< &ll.Comdat{Name: $2.(*ast.ComdatName).Name}, nil >>
;

Dereferenceable
	: "dereferenceable" "(" int_lit ")"
	<< &ll.Dereferenceable{N: astx.Int($2)}, nil >>
	| "dereferenceable_or_null" "(" int_lit ")"
	<< &ll.Dereferenceable{N: astx.Int($2), Null: true}, nil >>
;

// https://llvm.org/docs/LangRef.html#dll-storage-classes

// ref: ParseOptionalDLLStorageClass
//
//   ::= empty
//   ::= 'dllimport'
//   ::= 'dllexport'

OptDLLStorageClass
	: empty             << ll.DLLStorageClassNone, nil >>
	| DLLStorageClass
;

DLLStorageClass
	: "dllexport"   << ll.DLLStorageClassDLLExport, nil >>
	| "dllimport"   << ll.DLLStorageClassDLLImport, nil >>
;

// https://llvm.org/docs/LangRef.html#linkage-types

// ref: ParseOptionalLinkage
//
//   ::= empty
//   ::= 'private'
//   ::= 'internal'
//   ::= 'weak'
//   ::= 'weak_odr'
//   ::= 'linkonce'
//   ::= 'linkonce_odr'
//   ::= 'available_externally'
//   ::= 'appending'
//   ::= 'common'
//   ::= 'extern_weak'
//   ::= 'external'

OptLinkage
	: empty     << ll.LinkageNone, nil >>
	| Linkage
;

Linkage
	: "appending"              << ll.LinkageAppending, nil >>
	| "available_externally"   << ll.LinkageAvailableExternally, nil >>
	| "common"                 << ll.LinkageCommon, nil >>
	| "internal"               << ll.LinkageInternal, nil >>
	| "linkonce"               << ll.LinkageLinkOnce, nil >>
	| "linkonce_odr"           << ll.LinkageLinkOnceODR, nil >>
	| "private"                << ll.LinkagePrivate, nil >>
	| "weak"                   << ll.LinkageWeak, nil >>
	| "weak_odr"               << ll.LinkageWeakODR, nil >>
;

OptExternLinkage
	: empty           << ll.LinkageNone, nil >>
	| ExternLinkage
;

ExternLinkage
	: "extern_weak"   << ll.LinkageExternWeak, nil >>
	| "external"      << ll.LinkageExternal, nil >>
;

// https://llvm.org/docs/LangRef.html#runtime-preemption-model

// ref: ParseOptionalDSOLocal

OptPreemptionSpecifier
	: empty                 << ll.PreemptionNone, nil >>
	| PreemptionSpecifier
;

PreemptionSpecifier
	: "dso_local"         << ll.PreemptionDSOLocal, nil >>
	| "dso_preemptable"   << ll.PreemptionDSOPreemptable, nil >>
;

OptSection
	: empty
	<< (*ll.Section)(nil), nil >>
	| Section
;

Section
	: "section" StringLit
	<< &ll.Section{Name: $1.(string)}, nil >>
;

// ref: ParseOptionalStackAlignment
//
//   ::= empty
//   ::= 'alignstack' '(' 4 ')'
StackAlignment
	: "alignstack" "(" int_lit ")"
	<< &ll.StackAlignment{Align: astx.Int($2)}, nil >>
;

// ref: ParseOptionalUnnamedAddr

OptUnnamedAddr
	: empty         << ll.UnnamedAddrNone, nil >>
	| UnnamedAddr
;

UnnamedAddr
	: "local_unnamed_addr"   << ll.UnnamedAddrLocalUnnamedAddr, nil >>
	| "unnamed_addr"         << ll.UnnamedAddrUnnamedAddr, nil >>
;

// https://llvm.org/docs/LangRef.html#visibility-styles

// ref: ParseOptionalVisibility
//
//   ::= empty
//   ::= 'default'
//   ::= 'hidden'
//   ::= 'protected'

OptVisibility
	: empty        << ll.VisibilityNone, nil >>
	| Visibility
;

Visibility
	: "default"     << ll.VisibilityDefault, nil >>
	| "hidden"      << ll.VisibilityHidden, nil >>
	| "protected"   << ll.VisibilityProtected, nil >>
;

// ___ [ Instruction Operands ] ________________________________________________

// ref: ParseCmpPredicate

IPred
	: "eq"    << ll.IPredEQ, nil >>
	| "ne"    << ll.IPredNE, nil >>
	| "sge"   << ll.IPredSGE, nil >>
	| "sgt"   << ll.IPredSGT, nil >>
	| "sle"   << ll.IPredSLE, nil >>
	| "slt"   << ll.IPredSLT, nil >>
	| "uge"   << ll.IPredUGE, nil >>
	| "ugt"   << ll.IPredUGT, nil >>
	| "ule"   << ll.IPredULE, nil >>
	| "ult"   << ll.IPredULT, nil >>
;

// ref: ParseCmpPredicate

FPred
	: "false"   << ll.FPredFalse, nil >>
	| "oeq"     << ll.FPredOEQ, nil >>
	| "oge"     << ll.FPredOGE, nil >>
	| "ogt"     << ll.FPredOGT, nil >>
	| "ole"     << ll.FPredOLE, nil >>
	| "olt"     << ll.FPredOLT, nil >>
	| "one"     << ll.FPredONE, nil >>
	| "ord"     << ll.FPredORD, nil >>
	| "true"    << ll.FPredTrue, nil >>
	| "ueq"     << ll.FPredUEQ, nil >>
	| "uge"     << ll.FPredUGE, nil >>
	| "ugt"     << ll.FPredUGT, nil >>
	| "ule"     << ll.FPredULE, nil >>
	| "ult"     << ll.FPredULT, nil >>
	| "une"     << ll.FPredUNE, nil >>
	| "uno"     << ll.FPredUNO, nil >>
;

OverflowFlags
	: empty
	<< ([]ll.OverflowFlag)(nil), nil >>
	| OverflowFlagList
;

OverflowFlagList
	: OverflowFlag
	<< []ll.OverflowFlag{$0.(ll.OverflowFlag)}, nil >>
	| OverflowFlagList OverflowFlag
	<< append($0.([]ll.OverflowFlag), $1.(ll.OverflowFlag)), nil >>
;

OverflowFlag
	: "nsw"   << ll.OverflowFlagNSW, nil >>
	| "nuw"   << ll.OverflowFlagNUW, nil >>
;

OptExact
	: empty     << false, nil >>
	| "exact"   << true, nil >>
;

// ref: EatFastMathFlagsIfPresent

FastMathFlags
	: empty
	<< ([]ll.FastMathFlag)(nil), nil >>
	| FastMathFlagList
;

FastMathFlagList
	: FastMathFlag
	<< []ll.FastMathFlag{$0.(ll.FastMathFlag)}, nil >>
	| FastMathFlagList FastMathFlag
	<< append($0.([]ll.FastMathFlag), $1.(ll.FastMathFlag)), nil >>
;

FastMathFlag
	: "afn"        << ll.FastMathFlagAFn, nil >>
	| "arcp"       << ll.FastMathFlagARcp, nil >>
	| "contract"   << ll.FastMathFlagContract, nil >>
	| "fast"       << ll.FastMathFlagFast, nil >>
	| "ninf"       << ll.FastMathFlagNInf, nil >>
	| "nnan"       << ll.FastMathFlagNNaN, nil >>
	| "nsz"        << ll.FastMathFlagNSZ, nil >>
	| "reassoc"    << ll.FastMathFlagReassoc, nil >>
;

OptInBounds
	: empty        << false, nil >>
	| "inbounds"   << true, nil >>
;

// ref: ParseOptionalOperandBundles
//
//    ::= empty
//    ::= '[' OperandBundle [, OperandBundle ]* ']'
//
//  OperandBundle
//    ::= bundle-tag '(' ')'
//    ::= bundle-tag '(' Type Value [, Type Value ]* ')'
//
//  bundle-tag ::= String Constant

OperandBundles
	: empty
	<< ([]*ast.OperandBundle)(nil), nil >>
	| "[" OperandBundleList "]"
	<< $1, nil >>
;

OperandBundleList
	: OperandBundle
	<< []*ast.OperandBundle{$0.(*ast.OperandBundle)}, nil >>
	| OperandBundleList OperandBundle
	<< append($0.([]*ast.OperandBundle), $1.(*ast.OperandBundle)), nil >>
;

OperandBundle
	: StringLit "(" TypeValues ")"
	<< &ast.OperandBundle{Tag: $0.(string), Inputs: $2.([]value.Value)}, nil >>
;

OptVolatile
	: empty        << false, nil >>
	| "volatile"   << true, nil >>
;

// ref: ParseScope
//
//   ::= syncscope("singlethread" | "<target scope>")?

OptSyncScope
	: empty
	<< (*ll.SyncScope)(nil), nil >>
	| "syncscope" "(" StringLit ")"
	<< &ll.SyncScope{Scope: $2.(string)}, nil >>
;

// ref: ParseOrdering
//
//   ::= AtomicOrdering

AtomicOrdering
	: "acq_rel"     << ll.AtomicOrderingAcqRel, nil >>
	| "acquire"     << ll.AtomicOrderingAcquire, nil >>
	| "monotonic"   << ll.AtomicOrderingMonotonic, nil >>
	| "release"     << ll.AtomicOrderingRelease, nil >>
	| "seq_cst"     << ll.AtomicOrderingSeqCst, nil >>
	| "unordered"   << ll.AtomicOrderingUnordered, nil >>
;

ExceptionScope
	: NoneConst
	| LocalIdent
;

// ref: ParseIndexList
//
//    ::=  (',' uint32)+

Indices
	: empty
	<< ([]int64)(nil), nil >>
	| "," IndexList
	<< $1, nil >>
;

IndexList
	: Index
	<< []int64{$0.(int64)}, nil >>
	| IndexList "," Index
	<< append($0.([]int64), $2.(int64)), nil >>
;

Index
	: int_lit
	<< astx.Int($0), nil >>
;

TypeValues
	: empty
	<< ([]value.Value)(nil), nil >>
	| TypeValueList
;

TypeValueList
	: TypeValue
	<< []value.Value{$0.(*ast.TypeValue)}, nil >>
	| TypeValueList TypeValue
	<< append($0.([]value.Value), $1.(*ast.TypeValue)), nil >>
;

CommaSepTypeValueList
	: TypeValue
	<< []value.Value{$0.(*ast.TypeValue)}, nil >>
	| CommaSepTypeValueList "," TypeValue
	<< append($0.([]value.Value), $2.(*ast.TypeValue)), nil >>
;

TypeValue
	: Type Value
	<< astx.TypeValue($0, $1), nil >>
;

TypeConsts
	: empty
	<< ([]*ast.TypeConst)(nil), nil >>
	| TypeConstList
;

TypeConstList
	: TypeConst
	<< []*ast.TypeConst{$0.(*ast.TypeConst)}, nil >>
	| TypeConstList "," TypeConst
	<< append($0.([]*ast.TypeConst), $2.(*ast.TypeConst)), nil >>
;

TypeConst
	: Type Constant
	<< &ast.TypeConst{Typ: $0.(types.Type), Const: $1.(ast.Constant)}, nil >>
;

// ref: ParseParameterList
//
//    ::= '(' ')'
//    ::= '(' Arg (',' Arg)* ')'
//  Arg
//    ::= Type OptionalAttributes Value OptionalAttributes

Args
	: empty
	<< ([]ast.Argument)(nil), nil >>
	| "..."
	<< ([]ast.Argument)(nil), nil >>
	| ArgList
	<< $0, nil >>
	| ArgList "," "..."
	<< $0, nil >>
;

ArgList
	: Arg
	<< []ast.Argument{$0.(ast.Argument)}, nil >>
	| ArgList "," Arg
	<< append($0.([]ast.Argument), $2.(ast.Argument)), nil >>
;

// ref: ParseMetadataAsValue
//
//  ::= metadata i32 %local
//  ::= metadata i32 @global
//  ::= metadata i32 7
//  ::= metadata !0
//  ::= metadata !{...}
//  ::= metadata !"string"

Arg
	: ConcreteType ParamAttrs Value
	<< &ast.Arg{X: astx.TypeValue($0, $2), ParamAttrs: $1.([]ll.ParamAttribute)}, nil >>
	| MetadataType Metadata
	<< &ast.MetadataValue{Metadata: $1.(metadata.Metadata)}, nil >>
;

// ref: ParseExceptionArgs

ExceptionArgs
	: empty
	<< ([]ast.Argument)(nil), nil >>
	| ExceptionArgList
;

ExceptionArgList
	: ExceptionArg
	<< []ast.Argument{$0.(ast.Argument)}, nil >>
	| ExceptionArgList "," ExceptionArg
	<< append($0.([]ast.Argument), $2.(ast.Argument)), nil >>
;

ExceptionArg
	: ConcreteType Value
	<< astx.TypeValue($0, $1), nil >>
	| MetadataType Metadata
	<< &ast.MetadataValue{Metadata: $1.(metadata.Metadata)}, nil >>
;

// ref: ParseArgumentList
//
//   ::= '(' ArgTypeListI ')'
//  ArgTypeListI
//   ::= empty
//   ::= '...'
//   ::= ArgTypeList ',' '...'
//   ::= ArgType (',' ArgType)*

Params
	: empty
	<< &astx.Params{}, nil >>
	| "..."
	<< &astx.Params{Variadic: true}, nil >>
	| ParamList
	<< &astx.Params{Params: $0.([]*ll.Param)}, nil >>
	| ParamList "," "..."
	<< &astx.Params{Params: $0.([]*ll.Param), Variadic: true}, nil >>
;

ParamList
	: Param
	<< []*ll.Param{$0.(*ll.Param)}, nil >>
	| ParamList "," Param
	<< append($0.([]*ll.Param), $2.(*ll.Param)), nil >>
;

Param
	: Type ParamAttrs
	<< &ll.Param{Typ: $0.(types.Type), Attrs: $1.([]ll.ParamAttribute)}, nil >>
	| Type ParamAttrs LocalIdent
	<< &ll.Param{Typ: $0.(types.Type), Name: astx.LocalIdent($2), Attrs: $1.([]ll.ParamAttribute)}, nil >>
;

