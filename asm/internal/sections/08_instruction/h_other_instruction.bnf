// --- [ Other instructions ] --------------------------------------------------

// ~~~ [ icmp ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// https://llvm.org/docs/LangRef.html#icmp-instruction

// ref: ParseCompare
//
//  ::= 'icmp' IPredicates TypeAndValue ',' Value

ICmpInst
	: "icmp" IPred Type Value "," Value OptCommaSepMetadataAttachmentList
	<< &ast.ICmpInst{Pred: $1.(ast.IPred), X: astx.TypeValue($2, $3), Y: astx.TypeValue($2, $5), Metadata: $6.([]*ast.MetadataAttachment)}, nil >>
;

// ~~~ [ fcmp ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// https://llvm.org/docs/LangRef.html#fcmp-instruction

// ref: ParseCompare
//
//  ::= 'fcmp' FPredicates TypeAndValue ',' Value

FCmpInst
	: "fcmp" FastMathFlags FPred Type Value "," Value OptCommaSepMetadataAttachmentList
	<< &ast.FCmpInst{FastMathFlags: X[1].([]ast.FastMathFlag), Pred: $2.(ast.FPred), X: astx.TypeValue($3, $4), Y: astx.TypeValue($3, $6), Metadata: $7.([]*ast.MetadataAttachment)}, nil >>
;

// ~~~ [ phi ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// https://llvm.org/docs/LangRef.html#phi-instruction

// ref: ParsePHI
//
//   ::= 'phi' Type '[' Value ',' Value ']' (',' '[' Value ',' Value ']')*

PhiInst
	: "phi" Type IncList OptCommaSepMetadataAttachmentList
	<< &ast.PhiInst{Type: $1.(ast.Type), Incs: $2.([]*ast.Incoming), Metadata: $3.([]*ast.MetadataAttachment)}, nil >>
;

IncList
	: Inc
	<< []*ast.Incoming{$0.(*ast.Incoming)}, nil >>
	| IncList "," Inc
	<< append($0.([]*ast.Incoming), $2.(*ast.Incoming)), nil >>
;

Inc
	: "[" Value "," LocalIdent "]"
	<< &ast.Incoming{X: $1.(ast.Value), Pred: $3.(*ast.LocalIdent)}, nil >>
;

// ~~~ [ select ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// https://llvm.org/docs/LangRef.html#select-instruction

// ref: ParseSelect
//
//   ::= 'select' TypeAndValue ',' TypeAndValue ',' TypeAndValue

SelectInst
	: "select" Type Value "," Type Value "," Type Value OptCommaSepMetadataAttachmentList
	<< &ast.SelectInst{Cond: astx.TypeValue($1, $2), X: astx.TypeValue($4, $5), Y: astx.TypeValue($7, $8), Metadata: $9.([]*ast.MetadataAttachment)}, nil >>
;

// ~~~ [ call ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// https://llvm.org/docs/LangRef.html#call-instruction

// ref: ParseCall
//
//   ::= 'call' OptionalFastMathFlags OptionalCallingConv
//           OptionalAttrs Type Value ParameterList OptionalAttrs
//   ::= 'tail' 'call' OptionalFastMathFlags OptionalCallingConv
//           OptionalAttrs Type Value ParameterList OptionalAttrs
//   ::= 'musttail' 'call' OptionalFastMathFlags OptionalCallingConv
//           OptionalAttrs Type Value ParameterList OptionalAttrs
//   ::= 'notail' 'call'  OptionalFastMathFlags OptionalCallingConv
//           OptionalAttrs Type Value ParameterList OptionalAttrs

CallInst
	: OptTail "call" FastMathFlags OptCallingConv ReturnAttrs Type Value "(" Args ")" FuncAttrs OperandBundles OptCommaSepMetadataAttachmentList
	<< &ast.CallInst{Tail: $0.(ast.Tail), FastMathFlags: $2.([]ast.FastMathFlag), CallingConv: $3.(ast.CallingConv), ReturnAttrs: $4.([]ast.ReturnAttribute), RetType: $5.(ast.Type), Callee: $6.(ast.Value), Args: $8.([]ast.Argument), FuncAttrs: $10.([]ast.FuncAttribute), OperandBundles: $11.([]*ast.OperandBundle), Metadata: $12.([]*ast.MetadataAttachment)}, nil >>
;

OptTail
	: empty        << ast.TailNone, nil >>
	| "musttail"   << ast.TailMustTail, nil >>
	| "notail"     << ast.TailNoTail, nil >>
	| "tail"       << ast.TailTail, nil >>
;

// ~~~ [ va_arg ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// https://llvm.org/docs/LangRef.html#va_arg-instruction

// ref: ParseVA_Arg
//
//   ::= 'va_arg' TypeAndValue ',' Type

VAArgInst
	: "va_arg" Type Value "," Type OptCommaSepMetadataAttachmentList
	<< &ast.VAArgInst{ArgList: astx.TypeValue($1, $2), ArgType: $4.(ast.Type), Metadata: $5.([]*ast.MetadataAttachment)}, nil >>
;

// ~~~ [ landingpad ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// https://llvm.org/docs/LangRef.html#landingpad-instruction

// ref: ParseLandingPad
//
//   ::= 'landingpad' Type 'personality' TypeAndValue 'cleanup'? Clause+
//  Clause
//   ::= 'catch' TypeAndValue
//   ::= 'filter'
//   ::= 'filter' TypeAndValue ( ',' TypeAndValue )*

LandingPadInst
	: "landingpad" Type OptCleanup Clauses OptCommaSepMetadataAttachmentList
	<< &ast.LandingPadInst{Type: $1.(ast.Type), Cleanup: $2.(bool), Clauses: $3.([]*ast.Clause), Metadata: $4.([]*ast.MetadataAttachment)}, nil >>
;

OptCleanup
	: empty       << false, nil >>
	| "cleanup"   << true, nil >>
;

Clauses
	: empty
	<< ([]*ast.Clause)(nil), nil >>
	| ClauseList
;

ClauseList
	: Clause
	<< []*ast.Clause{$0.(*ast.Clause)}, nil >>
	| ClauseList Clause
	<< append($0.([]*ast.Clause), $1.(*ast.Clause)), nil >>
;

Clause
	: "catch" Type Value
	<< &ast.Clause{Catch: true, X: astx.TypeValue($1, $2)}, nil >>
	| "filter" Type ArrayConst
	<< &ast.Clause{X: astx.TypeValue($1, $2)}, nil >>
;

// --- [ catchpad ] ------------------------------------------------------------

// ref: ParseCatchPad
//
//   ::= 'catchpad' ParamList 'to' TypeAndValue 'unwind' TypeAndValue

CatchPadInst
	: "catchpad" "within" LocalIdent "[" ExceptionArgs "]" OptCommaSepMetadataAttachmentList
	<< &ast.CatchPadInst{Scope: $2.(*ast.LocalIdent), Args: $4.([]ast.Argument), Metadata: $6.([]*ast.MetadataAttachment)}, nil >>
;

// --- [ cleanuppad ] ----------------------------------------------------------

// ref: ParseCleanupPad
//
//   ::= 'cleanuppad' within Parent ParamList

CleanupPadInst
	: "cleanuppad" "within" ExceptionScope "[" ExceptionArgs "]" OptCommaSepMetadataAttachmentList
	<< &ast.CleanupPadInst{Scope: $2.(ast.ExceptionScope), Args: $4.([]ast.Argument), Metadata: $6.([]*ast.MetadataAttachment)}, nil >>
;

