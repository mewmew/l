// --- [ Other instructions ] --------------------------------------------------

// ~~~ [ icmp ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// https://llvm.org/docs/LangRef.html#icmp-instruction

// ref: ParseCompare
//
//  ::= 'icmp' IPredicates TypeAndValue ',' Value

ICmpInst
	: "icmp" IPred Type Value "," Value OptCommaSepMetadataAttachmentList
	<< &ir.ICmpInst{Pred: $1.(ll.IPred), X: astx.TypeValue($2, $3), Y: astx.TypeValue($2, $5), Metadata: $6.([]*metadata.MetadataAttachment)}, nil >>
;

// ~~~ [ fcmp ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// https://llvm.org/docs/LangRef.html#fcmp-instruction

// ref: ParseCompare
//
//  ::= 'fcmp' FPredicates TypeAndValue ',' Value

FCmpInst
	: "fcmp" FastMathFlags FPred Type Value "," Value OptCommaSepMetadataAttachmentList
	<< &ir.FCmpInst{FastMathFlags: X[1].([]ll.FastMathFlag), Pred: $2.(ll.FPred), X: astx.TypeValue($3, $4), Y: astx.TypeValue($3, $6), Metadata: $7.([]*metadata.MetadataAttachment)}, nil >>
;

// ~~~ [ phi ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// https://llvm.org/docs/LangRef.html#phi-instruction

// ref: ParsePHI
//
//   ::= 'phi' Type '[' Value ',' Value ']' (',' '[' Value ',' Value ']')*

PhiInst
	: "phi" Type IncList OptCommaSepMetadataAttachmentList
	<< &ir.PhiInst{Type: $1.(types.Type), Incs: $2.([]*ir.Incoming), Metadata: $3.([]*metadata.MetadataAttachment)}, nil >>
;

IncList
	: Inc
	<< []*ir.Incoming{$0.(*ir.Incoming)}, nil >>
	| IncList "," Inc
	<< append($0.([]*ir.Incoming), $2.(*ir.Incoming)), nil >>
;

Inc
	: "[" Value "," LocalIdent "]"
	<< &ir.Incoming{X: $1.(value.Value), Pred: &ir.BasicBlock{Name: astx.LocalIdent($3)}}, nil >>
;

// ~~~ [ select ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// https://llvm.org/docs/LangRef.html#select-instruction

// ref: ParseSelect
//
//   ::= 'select' TypeAndValue ',' TypeAndValue ',' TypeAndValue

SelectInst
	: "select" Type Value "," Type Value "," Type Value OptCommaSepMetadataAttachmentList
	<< &ir.SelectInst{Cond: astx.TypeValue($1, $2), X: astx.TypeValue($4, $5), Y: astx.TypeValue($7, $8), Metadata: $9.([]*metadata.MetadataAttachment)}, nil >>
;

// ~~~ [ call ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// https://llvm.org/docs/LangRef.html#call-instruction

// ref: ParseCall
//
//   ::= 'call' OptionalFastMathFlags OptionalCallingConv
//           OptionalAttrs Type Value ParameterList OptionalAttrs
//   ::= 'tail' 'call' OptionalFastMathFlags OptionalCallingConv
//           OptionalAttrs Type Value ParameterList OptionalAttrs
//   ::= 'musttail' 'call' OptionalFastMathFlags OptionalCallingConv
//           OptionalAttrs Type Value ParameterList OptionalAttrs
//   ::= 'notail' 'call'  OptionalFastMathFlags OptionalCallingConv
//           OptionalAttrs Type Value ParameterList OptionalAttrs

CallInst
	: OptTail "call" FastMathFlags OptCallingConv ReturnAttrs Type Value "(" Args ")" FuncAttrs OperandBundles OptCommaSepMetadataAttachmentList
	<< &ir.CallInst{Tail: $0.(ll.Tail), FastMathFlags: $2.([]ll.FastMathFlag), CallingConv: $3.(ll.CallingConv), ReturnAttrs: $4.([]ll.ReturnAttribute), RetType: $5.(types.Type), Callee: $6.(value.Value), Args: $8.([]ll.Argument), FuncAttrs: $10.([]ll.FuncAttribute), OperandBundles: $11.([]*ll.OperandBundle), Metadata: $12.([]*metadata.MetadataAttachment)}, nil >>
;

OptTail
	: empty        << ll.TailNone, nil >>
	| "musttail"   << ll.TailMustTail, nil >>
	| "notail"     << ll.TailNoTail, nil >>
	| "tail"       << ll.TailTail, nil >>
;

// ~~~ [ va_arg ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// https://llvm.org/docs/LangRef.html#va_arg-instruction

// ref: ParseVA_Arg
//
//   ::= 'va_arg' TypeAndValue ',' Type

VAArgInst
	: "va_arg" Type Value "," Type OptCommaSepMetadataAttachmentList
	<< &ir.VAArgInst{ArgList: astx.TypeValue($1, $2), ArgType: $4.(types.Type), Metadata: $5.([]*metadata.MetadataAttachment)}, nil >>
;

// ~~~ [ landingpad ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// https://llvm.org/docs/LangRef.html#landingpad-instruction

// ref: ParseLandingPad
//
//   ::= 'landingpad' Type 'personality' TypeAndValue 'cleanup'? Clause+
//  Clause
//   ::= 'catch' TypeAndValue
//   ::= 'filter'
//   ::= 'filter' TypeAndValue ( ',' TypeAndValue )*

LandingPadInst
	: "landingpad" Type OptCleanup Clauses OptCommaSepMetadataAttachmentList
	<< &ir.LandingPadInst{Type: $1.(types.Type), Cleanup: $2.(bool), Clauses: $3.([]*ir.Clause), Metadata: $4.([]*metadata.MetadataAttachment)}, nil >>
;

OptCleanup
	: empty       << false, nil >>
	| "cleanup"   << true, nil >>
;

Clauses
	: empty
	<< ([]*ir.Clause)(nil), nil >>
	| ClauseList
;

ClauseList
	: Clause
	<< []*ir.Clause{$0.(*ir.Clause)}, nil >>
	| ClauseList Clause
	<< append($0.([]*ir.Clause), $1.(*ir.Clause)), nil >>
;

Clause
	: "catch" Type Value
	<< &ir.Clause{Catch: true, X: astx.TypeValue($1, $2)}, nil >>
	| "filter" Type ArrayConst
	<< &ir.Clause{X: astx.TypeValue($1, $2)}, nil >>
;

// --- [ catchpad ] ------------------------------------------------------------

// ref: ParseCatchPad
//
//   ::= 'catchpad' ParamList 'to' TypeAndValue 'unwind' TypeAndValue

CatchPadInst
	: "catchpad" "within" LocalIdent "[" ExceptionArgs "]" OptCommaSepMetadataAttachmentList
	<< &ir.CatchPadInst{Scope: $2.(*ast.LocalIdent), Args: $4.([]ll.Argument), Metadata: $6.([]*metadata.MetadataAttachment)}, nil >>
;

// --- [ cleanuppad ] ----------------------------------------------------------

// ref: ParseCleanupPad
//
//   ::= 'cleanuppad' within Parent ParamList

CleanupPadInst
	: "cleanuppad" "within" ExceptionScope "[" ExceptionArgs "]" OptCommaSepMetadataAttachmentList
	<< &ir.CleanupPadInst{Scope: $2.(ll.ExceptionScope), Args: $4.([]ll.Argument), Metadata: $6.([]*metadata.MetadataAttachment)}, nil >>
;

