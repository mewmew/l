// === [ Terminators ] =========================================================

/*
/// ParseInstruction - Parse one of the many different instructions.
///
int LLParser::ParseInstruction(Instruction *&Inst, BasicBlock *BB,
*/

/*
/// ParseInstructionMetadata
///   ::= !dbg !42 (',' !dbg !57)*
bool LLParser::ParseInstructionMetadata(Instruction &Inst) {
*/

Terminator
	: UnreachableTerm
	| RetTerm
	| BrTerm
	| SwitchTerm
	| IndirectBrTerm
	| InvokeTerm
	| ResumeTerm
	| CleanupRetTerm
	| CatchRetTerm
	| CatchSwitchTerm
	| CatchPadTerm
	| CleanupPadTerm
;

// --- [ unreachable ] ---------------------------------------------------------

UnreachableTerm
	: "unreachable"
;

// --- [ ret ] -----------------------------------------------------------------

/*
/// ParseRet - Parse a return instruction.
///   ::= 'ret' void (',' !dbg, !1)*
///   ::= 'ret' TypeAndValue (',' !dbg, !1)*
bool LLParser::ParseRet(Instruction *&Inst, BasicBlock *BB,
*/

RetTerm
	: "ret" VoidType MetadataAttachments
	| "ret" Type Value MetadataAttachments
;

// --- [ br ] ------------------------------------------------------------------

/*
/// ParseBr
///   ::= 'br' TypeAndValue
///   ::= 'br' TypeAndValue ',' TypeAndValue ',' TypeAndValue
bool LLParser::ParseBr(Instruction *&Inst, PerFunctionState &PFS) {
*/

BrTerm
	: "br" Type LocalIdent MetadataAttachments
	| "br" Type Value "," Type LocalIdent "," Type LocalIdent MetadataAttachments
;

// --- [ switch ] --------------------------------------------------------------

/*
/// ParseSwitch
///  Instruction
///    ::= 'switch' TypeAndValue ',' TypeAndValue '[' JumpTable ']'
///  JumpTable
///    ::= (TypeAndValue ',' TypeAndValue)*
bool LLParser::ParseSwitch(Instruction *&Inst, PerFunctionState &PFS) {
*/

SwitchTerm
	: "switch" Type Value "," Type LocalIdent "[" Cases "]" MetadataAttachments
;

Cases
	: empty
	| CaseList
;

CaseList
	: Case
	| CaseList Case
;

Case
	: Type IntConst "," Type LocalIdent
;

// --- [ indirectbr ] ----------------------------------------------------------

/*
/// ParseIndirectBr
///  Instruction
///    ::= 'indirectbr' TypeAndValue ',' '[' LabelList ']'
bool LLParser::ParseIndirectBr(Instruction *&Inst, PerFunctionState &PFS) {
*/

IndirectBrTerm
	: "indirectbr" Type Value "," "[" LabelList "]" MetadataAttachments
;

LabelList
	: Label
	| LabelList "," Label
;

Label
	: Type LocalIdent
;

// --- [ invoke ] --------------------------------------------------------------

/*
/// ParseInvoke
///   ::= 'invoke' OptionalCallingConv OptionalAttrs Type Value ParamList
///       OptionalAttrs 'to' TypeAndValue 'unwind' TypeAndValue
bool LLParser::ParseInvoke(Instruction *&Inst, PerFunctionState &PFS) {
*/

InvokeTerm
	: "invoke" OptCallingConv ReturnAttrs Type Value "(" Params ")" FuncAttrs OperandBundles "to" Type LocalIdent "unwind" Type LocalIdent MetadataAttachments
;

/*
/// ParseOptionalOperandBundles
///    ::= empty
///    ::= '[' OperandBundle [, OperandBundle ]* ']'
///
/// OperandBundle
///    ::= bundle-tag '(' ')'
///    ::= bundle-tag '(' Type Value [, Type Value ]* ')'
///
/// bundle-tag ::= String Constant
bool LLParser::ParseOptionalOperandBundles(
*/

OperandBundles
	: empty
	| "[" OperandBundleList "]"
;

OperandBundleList
	: OperandBundle
	| OperandBundleList OperandBundle
;

OperandBundle
	: string_lit "(" BundleInputs ")"
;

BundleInputs
	: empty
	| BundleInputList
;

BundleInputList
	: BundleInput
	| BundleInputList BundleInput
;

BundleInput
	: Type Value
;

// --- [ resume ] --------------------------------------------------------------

/*
/// ParseResume
///   ::= 'resume' TypeAndValue
bool LLParser::ParseResume(Instruction *&Inst, PerFunctionState &PFS) {
*/

ResumeTerm
	: "resume" Type Value MetadataAttachments
;

// --- [ cleanupret ] ----------------------------------------------------------

/*
/// ParseCleanupRet
///   ::= 'cleanupret' from Value unwind ('to' 'caller' | TypeAndValue)
bool LLParser::ParseCleanupRet(Instruction *&Inst, PerFunctionState &PFS) {
*/

CleanupRetTerm
	: "cleanupret" "from" Value "unwind" UnwindTarget MetadataAttachments
;

UnwindTarget
	: "to" "caller"
	| Type LocalIdent
;

// --- [ catchret ] ------------------------------------------------------------

/*
/// ParseCatchRet
///   ::= 'catchret' from Parent Value 'to' TypeAndValue
bool LLParser::ParseCatchRet(Instruction *&Inst, PerFunctionState &PFS) {
*/

CatchRetTerm
	: "catchret" "from" Value "to" Type LocalIdent MetadataAttachments
;

// --- [ catchswitch ] ---------------------------------------------------------

/*
/// ParseCatchSwitch
///   ::= 'catchswitch' within Parent
bool LLParser::ParseCatchSwitch(Instruction *&Inst, PerFunctionState &PFS) {
*/

CatchSwitchTerm
	: "catchswitch" "within" ExceptionScope Value "[" LabelList "]" "unwind" UnwindTarget MetadataAttachments
;

ExceptionScope
	: "none"
	| LocalIdent
;

// --- [ catchpad ] ------------------------------------------------------------

/*
/// ParseCatchPad
///   ::= 'catchpad' ParamList 'to' TypeAndValue 'unwind' TypeAndValue
bool LLParser::ParseCatchPad(Instruction *&Inst, PerFunctionState &PFS) {
*/

CatchPadTerm
	: "catchpad" "within" LocalIdent Value "[" ExceptionArgs "]" MetadataAttachments
;

/*
bool LLParser::ParseExceptionArgs(SmallVectorImpl<Value *> &Args,
*/

ExceptionArgs
	: empty
	| ExceptionArgList
;

ExceptionArgList
	: ExceptionArg
	| ExceptionArgList "," ExceptionArg
;

ExceptionArg
	: Type Value
	| MetadataType Metadata
;

// --- [ cleanuppad ] ----------------------------------------------------------

/*
/// ParseCleanupPad
///   ::= 'cleanuppad' within Parent ParamList
bool LLParser::ParseCleanupPad(Instruction *&Inst, PerFunctionState &PFS) {
*/

CleanupPadTerm
	: "cleanuppad" "within" ExceptionScope Value "[" ExceptionArgs "]" MetadataAttachments
;

