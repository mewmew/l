// --- [ Binary instructions ] -------------------------------------------------

/*
/// ParseArithmetic
///  ::= ArithmeticOps TypeAndValue ',' Value
///
/// If OperandType is 0, then any FP or integer operand is allowed.  If it is 1,
/// then any integer operand is allowed, if it is 2, any fp operand is allowed.
bool LLParser::ParseArithmetic(Instruction *&Inst, PerFunctionState &PFS,
*/

// ~~~ [ add ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

AddInst
	: "add" OverflowFlags Type Value "," Value
;

// ~~~ [ sub ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SubInst
	: "sub" OverflowFlags Type Value "," Value
;

// ~~~ [ mul ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MulInst
	: "mul" OverflowFlags Type Value "," Value
;

// ~~~ [ shl ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ShlInst
	: "shl" OverflowFlags Type Value "," Value
;

// ~~~ [ fadd ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FAddInst
	: "fadd" FastMathFlags Type Value "," Value
;

// ~~~ [ fsub ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FSubInst
	: "fsub" FastMathFlags Type Value "," Value
;

// ~~~ [ fmul ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FMulInst
	: "fmul" FastMathFlags Type Value "," Value
;

// ~~~ [ fdiv ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FDivInst
	: "fdiv" FastMathFlags Type Value "," Value
;

// ~~~ [ frem ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FRemInst
	: "frem" FastMathFlags Type Value "," Value
;

// ~~~ [ sdiv ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SDivInst
	: "sdiv" OptExact Type Value "," Value
;

// ~~~ [ udiv ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

UDivInst
	: "udiv" OptExact Type Value "," Value
;

// ~~~ [ lshr ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

LShrInst
	: "lshr" OptExact Type Value "," Value
;

// ~~~ [ ashr ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

AShrInst
	: "ashr" OptExact Type Value "," Value
;

// ~~~ [ urem ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

URemInst
	: "urem" Type Value "," Value
;

// ~~~ [ srem ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SRemInst
	: "srem" Type Value "," Value
;

/*
/// ParseLogical
///  ::= ArithmeticOps TypeAndValue ',' Value {
bool LLParser::ParseLogical(Instruction *&Inst, PerFunctionState &PFS,
*/

// ~~~ [ and ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

AndInst
	: "and" Type Value "," Value
;

// ~~~ [ or ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

OrInst
	: "or" Type Value "," Value
;

// ~~~ [ xor ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

XorInst
	: "xor" Type Value "," Value
;

/*
/// ParseCompare
///  ::= 'icmp' IPredicates TypeAndValue ',' Value
///  ::= 'fcmp' FPredicates TypeAndValue ',' Value
bool LLParser::ParseCompare(Instruction *&Inst, PerFunctionState &PFS,
*/

// ~~~ [ icmp ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ICmpInst
	: "icmp" IPred Type Value "," Value
;

// ~~~ [ fcmp ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FCmpInst
	: "fcmp" FastMathFlags FPred Type Value "," Value
;

/*
/// ParseCast
///   ::= CastOpc TypeAndValue 'to' Type
bool LLParser::ParseCast(Instruction *&Inst, PerFunctionState &PFS,
*/

// ~~~ [ trunc ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TruncInst
	: "trunc" Type Value "to" Value
;

// ~~~ [ zext ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ZExtInst
	: "zext" Type Value "to" Value
;

// ~~~ [ sext ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SExtInst
	: "sext" Type Value "to" Value
;

// ~~~ [ fptrunc ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FPTruncInst
	: "fptrunc" Type Value "to" Value
;

// ~~~ [ fpext ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FPExtInst
	: "fpext" Type Value "to" Value
;

// ~~~ [ bitcast ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

BitCastInst
	: "bitcast" Type Value "to" Value
;

// ~~~ [ addrspacecast ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

AddrSpaceCastInst
	: "addrspacecast" Type Value "to" Value
;

// ~~~ [ uitofp ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

UIToFPInst
	: "uitofp" Type Value "to" Value
;

// ~~~ [ sitofp ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SIToFPInst
	: "sitofp" Type Value "to" Value
;

// ~~~ [ fptoui ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FPToUIInst
	: "fptoui" Type Value "to" Value
;

// ~~~ [ fptosi ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FPToSIInst
	: "fptosi" Type Value "to" Value
;

// ~~~ [ inttoptr ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

IntToPtrInst
	: "inttoptr" Type Value "to" Value
;

// ~~~ [ ptrtoint ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PtrToIntInst
	: "ptrtoint" Type Value "to" Value
;

// ~~~ [ select ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*
/// ParseSelect
///   ::= 'select' TypeAndValue ',' TypeAndValue ',' TypeAndValue
bool LLParser::ParseSelect(Instruction *&Inst, PerFunctionState &PFS) {
*/

SelectInst
	: "select" Type Value "," Type Value "," Type Value
;

// ~~~ [ va_arg ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*
/// ParseVA_Arg
///   ::= 'va_arg' TypeAndValue ',' Type
bool LLParser::ParseVA_Arg(Instruction *&Inst, PerFunctionState &PFS) {
*/

VAArgInst
	: "va_arg" Type Value "," Type
;

// ~~~ [ extractelement ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*
/// ParseExtractElement
///   ::= 'extractelement' TypeAndValue ',' TypeAndValue
bool LLParser::ParseExtractElement(Instruction *&Inst, PerFunctionState &PFS) {
*/

ExtractElementInst
	: "extractelement" Type Value "," Type Value
;

// ~~~ [ insertelement ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*
/// ParseInsertElement
///   ::= 'insertelement' TypeAndValue ',' TypeAndValue ',' TypeAndValue
bool LLParser::ParseInsertElement(Instruction *&Inst, PerFunctionState &PFS) {
*/

InsertElementInst
	: "insertelement" Type Value "," Type Value "," Type Value
;

// ~~~ [ shufflevector ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*
/// ParseShuffleVector
///   ::= 'shufflevector' TypeAndValue ',' TypeAndValue ',' TypeAndValue
bool LLParser::ParseShuffleVector(Instruction *&Inst, PerFunctionState &PFS) {
*/

ShuffleVectorInst
	: "shufflevector" Type Value "," Type Value "," Type Value
;

// ~~~ [ phi ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*
/// ParsePHI
///   ::= 'phi' Type '[' Value ',' Value ']' (',' '[' Value ',' Value ']')*
int LLParser::ParsePHI(Instruction *&Inst, PerFunctionState &PFS) {
*/

PhiInst
	: "phi" Type IncList
;

IncList
	: Inc
	| IncList Inc
;

Inc
	: "[" Value "," LocalIdent "]"
;

// ~~~ [ landingpad ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*
/// ParseLandingPad
///   ::= 'landingpad' Type 'personality' TypeAndValue 'cleanup'? Clause+
/// Clause
///   ::= 'catch' TypeAndValue
///   ::= 'filter'
///   ::= 'filter' TypeAndValue ( ',' TypeAndValue )*
bool LLParser::ParseLandingPad(Instruction *&Inst, PerFunctionState &PFS) {
*/

LandingPadInst
	: "landingpad" Type OptCleanup Clauses
;

OptCleanup
	: empty
	| "cleanup"
;

Clauses
	: empty
	| ClauseList
;

ClauseList
	: Clause
	| ClauseList Clause
;

Clause
	: "catch" Type Value
	| "filter" Type ArrayConst
;

// ~~~ [ call ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*
/// ParseCall
///   ::= 'call' OptionalFastMathFlags OptionalCallingConv
///           OptionalAttrs Type Value ParameterList OptionalAttrs
///   ::= 'tail' 'call' OptionalFastMathFlags OptionalCallingConv
///           OptionalAttrs Type Value ParameterList OptionalAttrs
///   ::= 'musttail' 'call' OptionalFastMathFlags OptionalCallingConv
///           OptionalAttrs Type Value ParameterList OptionalAttrs
///   ::= 'notail' 'call'  OptionalFastMathFlags OptionalCallingConv
///           OptionalAttrs Type Value ParameterList OptionalAttrs
bool LLParser::ParseCall(Instruction *&Inst, PerFunctionState &PFS,
*/

CallInst
	: "call" OptTail FastMathFlags OptCallingConv ReturnAttrs Type Value "(" Params ")" FuncAttrs OperandBundles
;

OptTail
	: empty
	| "tail"
	| "musttail"
	| "notail"
;

//===----------------------------------------------------------------------===//
// Memory Instructions.
//===----------------------------------------------------------------------===//

// ~~~ [ alloca ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*
/// ParseAlloc
///   ::= 'alloca' 'inalloca'? 'swifterror'? Type (',' TypeAndValue)?
///       (',' 'align' i32)? (',', 'addrspace(n))?
int LLParser::ParseAlloc(Instruction *&Inst, PerFunctionState &PFS) {
*/

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    AllocaInst
//       : "alloca" OptInalloca OptSwiftError Type OptCommaTypeValue OptCommaAlignment OptCommaAddrSpace
//    ;

AllocaInst
	: "alloca" OptInalloca OptSwiftError Type
	| "alloca" OptInalloca OptSwiftError Type "," Alignment
	| "alloca" OptInalloca OptSwiftError Type "," Type Value
	| "alloca" OptInalloca OptSwiftError Type "," Type Value "," Alignment
	| "alloca" OptInalloca OptSwiftError Type "," AddrSpace
	| "alloca" OptInalloca OptSwiftError Type "," Alignment "," AddrSpace
	| "alloca" OptInalloca OptSwiftError Type "," Type Value "," AddrSpace
	| "alloca" OptInalloca OptSwiftError Type "," Type Value "," Alignment "," AddrSpace
;

OptInalloca
	: empty
	| "inalloca"
;

OptSwiftError
	: empty
	| "swifterror"
;

// ~~~ [ load ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*
/// ParseLoad
///   ::= 'load' 'volatile'? TypeAndValue (',' 'align' i32)?
///   ::= 'load' 'atomic' 'volatile'? TypeAndValue
///       'singlethread'? AtomicOrdering (',' 'align' i32)?
int LLParser::ParseLoad(Instruction *&Inst, PerFunctionState &PFS) {
*/

/*
/// ParseScopeAndOrdering
///   if isAtomic: ::= SyncScope? AtomicOrdering
///   else: ::=
///
/// This sets Scope and Ordering to the parsed values.
bool LLParser::ParseScopeAndOrdering(bool isAtomic, SyncScope::ID &SSID,
*/

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    LoadInst
//       : "load" OptVolatile Type "," Type Value OptCommaAlignment
//       | "load" "atomic" OptVolatile Type "," Type Value OptScope AtomicOrdering OptCommaAlignment
//    ;

LoadInst
	: "load" OptVolatile Type "," Type Value
	| "load" OptVolatile Type "," Type Value "," Alignment
	| "load" "atomic" OptVolatile Type "," Type Value OptScope AtomicOrdering
	| "load" "atomic" OptVolatile Type "," Type Value OptScope AtomicOrdering "," Alignment
;

// ~~~ [ store ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*
/// ParseStore
///   ::= 'store' 'volatile'? TypeAndValue ',' TypeAndValue (',' 'align' i32)?
///   ::= 'store' 'atomic' 'volatile'? TypeAndValue ',' TypeAndValue
///       'singlethread'? AtomicOrdering (',' 'align' i32)?
int LLParser::ParseStore(Instruction *&Inst, PerFunctionState &PFS) {
*/

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    StoreInst
//       : "store" OptVolatile Type Value "," Type Value OptCommaAlignment
//       | "store" "atomic" OptVolatile Type Value "," Type Value OptScope AtomicOrdering OptCommaAlignment
//    ;

StoreInst
	: "store" OptVolatile Type Value "," Type Value
	| "store" OptVolatile Type Value "," Type Value "," Alignment
	| "store" "atomic" OptVolatile Type Value "," Type Value OptScope AtomicOrdering
	| "store" "atomic" OptVolatile Type Value "," Type Value OptScope AtomicOrdering "," Alignment
;

// ~~~ [ cmpxchg ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*
/// ParseCmpXchg
///   ::= 'cmpxchg' 'weak'? 'volatile'? TypeAndValue ',' TypeAndValue ','
///       TypeAndValue 'singlethread'? AtomicOrdering AtomicOrdering
int LLParser::ParseCmpXchg(Instruction *&Inst, PerFunctionState &PFS) {
*/

CmpXchgInst
	: "cmpxchg" OptWeak OptVolatile Type Value "," Type Value "," Type Value OptScope AtomicOrdering AtomicOrdering
;

OptWeak
	: empty
	| "weak"
;

// ~~~ [ atomicrmw ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*
/// ParseAtomicRMW
///   ::= 'atomicrmw' 'volatile'? BinOp TypeAndValue ',' TypeAndValue
///       'singlethread'? AtomicOrdering
int LLParser::ParseAtomicRMW(Instruction *&Inst, PerFunctionState &PFS) {
*/

AtomicRMWInst
	: "atomicrmw" OptVolatile BinOp Type Value "," Type Value OptScope AtomicOrdering
;

BinOp
	: "xchg"
	| "add"
	| "sub"
	| "and"
	| "nand"
	| "or"
	| "xor"
	| "max"
	| "min"
	| "umax"
	| "umin"
;

// ~~~ [ fence ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*
/// ParseFence
///   ::= 'fence' 'singlethread'? AtomicOrdering
int LLParser::ParseFence(Instruction *&Inst, PerFunctionState &PFS) {
*/

FenceInst
	: "fence" OptScope AtomicOrdering
;

// ~~~ [ getelementptr ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*
/// ParseGetElementPtr
///   ::= 'getelementptr' 'inbounds'? TypeAndValue (',' TypeAndValue)*
int LLParser::ParseGetElementPtr(Instruction *&Inst, PerFunctionState &PFS) {
*/

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    GetElementPtrInst
//       : "getelementptr" OptInBounds Type "," Type Value GEPIndices
//    ;

GetElementPtrInst
	: "getelementptr" OptInBounds Type "," Type Value
	| "getelementptr" OptInBounds Type "," Type Value "," GEPIndexList
;

GEPIndices
	: empty
	| "," GEPIndexList
;

GEPIndexList
	: GEPIndex
	| GEPIndexList "," GEPIndex
;

GEPIndex
	: Type Value
;

// ~~~ [ extractvalue ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*
/// ParseExtractValue
///   ::= 'extractvalue' TypeAndValue (',' uint32)+
int LLParser::ParseExtractValue(Instruction *&Inst, PerFunctionState &PFS) {
*/

ExtractValueInst
	: "extractvalue" Type Value "," IndexList
;

// ~~~ [ insertvalue ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*
/// ParseInsertValue
///   ::= 'insertvalue' TypeAndValue ',' TypeAndValue (',' uint32)+
int LLParser::ParseInsertValue(Instruction *&Inst, PerFunctionState &PFS) {
*/

InsertValueInst
	: "insertvalue" Type Value "," Type Value "," IndexList
;

// --- [ cleanuppad ] ----------------------------------------------------------

/*
/// ParseCleanupPad
///   ::= 'cleanuppad' within Parent ParamList
bool LLParser::ParseCleanupPad(Instruction *&Inst, PerFunctionState &PFS) {
*/

CleanupPadInst
	: "cleanuppad" "within" ExceptionScope Value "[" ExceptionArgs "]"
;

/*
bool LLParser::ParseExceptionArgs(SmallVectorImpl<Value *> &Args,
*/

ExceptionArgs
	: empty
	| ExceptionArgList
;

ExceptionArgList
	: ExceptionArg
	| ExceptionArgList "," ExceptionArg
;

ExceptionArg
	: ConcreteType Value
	| MetadataType Metadata
;

// --- [ catchpad ] ------------------------------------------------------------

/*
/// ParseCatchPad
///   ::= 'catchpad' ParamList 'to' TypeAndValue 'unwind' TypeAndValue
bool LLParser::ParseCatchPad(Instruction *&Inst, PerFunctionState &PFS) {
*/

CatchPadInst
	: "catchpad" "within" LocalIdent Value "[" ExceptionArgs "]"
;

