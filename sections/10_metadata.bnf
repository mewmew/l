/*
/// ParseGlobalObjectMetadataAttachment
///   ::= !dbg !57
bool LLParser::ParseGlobalObjectMetadataAttachment(GlobalObject &GO) {
*/

/*
/// ParseMetadataAttachment
///   ::= !dbg !42
bool LLParser::ParseMetadataAttachment(unsigned &Kind, MDNode *&MD) {
*/

MetadataAttachments
	: empty
	| MetadataAttachmentList
;

MetadataAttachmentList
	: MetadataAttachment
	| MetadataAttachmentList MetadataAttachment
;

MetadataAttachment
	: MetadataName MDNode
;

/*
/// MDNode:
///  ::= !{ ... }
///  ::= !7
///  ::= !DILocation(...)
bool LLParser::ParseMDNode(MDNode *&N) {
*/

MDNode
	: SpecializedMDNode
	// !{ ... }
	| MDTuple
	// !42
	| MetadataID
;

/*
bool LLParser::ParseSpecializedMDNode(MDNode *&N, bool IsDistinct) {
*/

SpecializedMDNode
	: DILocation
	| GenericDINode
	| DISubrange
	| DIEnumerator
;

/*
/// ParseDILocationFields:
///   ::= !DILocation(line: 43, column: 8, scope: !5, inlinedAt: !6)
bool LLParser::ParseDILocation(MDNode *&Result, bool IsDistinct) {

  OPTIONAL(line, LineField, );
  OPTIONAL(column, ColumnField, );
  REQUIRED(scope, MDField, (AllowNull false));
  OPTIONAL(inlinedAt, MDField, );
*/

DILocation
	: "!DILocation" "(" OptLineComma OptColumnComma Scope OptCommaInlinedAt ")"
;

OptLineComma
	: Line ","
;

Line
	: "line:" int_lit
;

OptColumnComma
	: Column ","
;

Column
	: "column:" int_lit
;

Scope
	: "scope:" MetadataID // underlying Metadata
;

OptCommaInlinedAt
	: empty
	| "," InlinedAt
;

InlinedAt
	: "inlinedAt:" MDField
;

MDField
	: MetadataID
	| "null"
;

/*
/// ParseGenericDINode:
///   ::= !GenericDINode(tag: 15, header: "...", operands: {...})
bool LLParser::ParseGenericDINode(MDNode *&Result, bool IsDistinct) {

  REQUIRED(tag, DwarfTagField, );
  OPTIONAL(header, MDStringField, );
  OPTIONAL(operands, MDFieldList, );
*/

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    GenericDINode
//       : "!GenericDINode" "(" Tag OptCommaHeader OptCommaOperands ")"
//    ;

GenericDINode
	: "!GenericDINode" "(" Tag OptCommaOperands ")"
	| "!GenericDINode" "(" Tag "," Header OptCommaOperands ")"
;

Tag
	: "tag:" DwarfTag
;

DwarfTag
	: int_lit
	// DW_TAG_foo
	| dwarf_tag
;

OptCommaHeader
	: empty
	| "," Header
;

Header
	: "header:" string_lit
;

OptCommaOperands
	: empty
	| "," Operands
;

Operands
	: "operands:" Metadatas
;

/*
/// ParseDISubrange:
///   ::= !DISubrange(count: 30, lowerBound: 2)
///   ::= !DISubrange(count: !node, lowerBound: 2)
bool LLParser::ParseDISubrange(MDNode *&Result, bool IsDistinct) {

  REQUIRED(count, MDSignedOrMDField, (-1, -1, INT64_MAX, false));
  OPTIONAL(lowerBound, MDSignedField, );
*/

DISubrange
	: "!DISubrange" "(" Count OptCommaLowerBound ")"
;

Count
	: "count:" IntLitOrMDField
;

/*
struct MDSignedOrMDField : MDEitherFieldImpl<MDSignedField, MDField> {
*/

IntLitOrMDField
	: int_lit
	| MDField
;

OptCommaLowerBound
	: empty
	| "," LowerBound
;

LowerBound
	: "lowerBound:" int_lit
;

/*
/// ParseDIEnumerator:
///   ::= !DIEnumerator(value: 30, isUnsigned: true, name: "SomeKind")
bool LLParser::ParseDIEnumerator(MDNode *&Result, bool IsDistinct) {

  REQUIRED(name, MDStringField, );
  REQUIRED(value, MDSignedOrUnsignedField, );
  OPTIONAL(isUnsigned, MDBoolField, (false));
*/

DIEnumerator
	: "!DIEnumerator" "(" Name DIEnumeratorValue OptCommaIsUnsigned ")"
;

Name
	: "name:" string_lit
;

DIEnumeratorValue
	: "value:" int_lit
;

OptCommaIsUnsigned
	: empty
	| "," IsUnsigned
;

IsUnsigned
	: "isUnsigned:" BoolConst
;

/*
bool LLParser::ParseMDTuple(MDNode *&MD, bool IsDistinct) {
*/

MDTuple
	: "!" "{" Metadatas "}"
;

//===----------------------------------------------------------------------===//
// Embedded metadata.
//===----------------------------------------------------------------------===//

/*
/// ParseMDNodeVector
///   ::= { Element (',' Element)* }
/// Element
///   ::= 'null' | TypeAndValue
bool LLParser::ParseMDNodeVector(SmallVectorImpl<Metadata *> &Elts) {
*/

Metadatas
	: "null"
	| Metadata
;

MetadataList
	: Metadata
	| MetadataList "," Metadata
;

/*
/// ParseMetadata
///  ::= i32 %local
///  ::= i32 @global
///  ::= i32 7
///  ::= !42
///  ::= !{...}
///  ::= !"string"
///  ::= !DILocation(...)
bool LLParser::ParseMetadata(Metadata *&MD, PerFunctionState *PFS) {
*/

Metadata
	: SpecializedMDNode
	| Type Value
	| MDString
	// !{ ... }
	| MDTuple
	// !7
	| MetadataID
;

MDString
	: "!" string_lit
;

