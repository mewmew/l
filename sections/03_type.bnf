//===----------------------------------------------------------------------===//
// Type Parsing.
//===----------------------------------------------------------------------===//

/*
/// ParseType - Parse a type.
bool LLParser::ParseType(Type *&Result, const Twine &Msg, bool AllowVoid) {
*/

/*
  TYPEKEYWORD("void",      Type::getVoidTy(Context));
  TYPEKEYWORD("half",      Type::getHalfTy(Context));
  TYPEKEYWORD("float",     Type::getFloatTy(Context));
  TYPEKEYWORD("double",    Type::getDoubleTy(Context));
  TYPEKEYWORD("x86_fp80",  Type::getX86_FP80Ty(Context));
  TYPEKEYWORD("fp128",     Type::getFP128Ty(Context));
  TYPEKEYWORD("ppc_fp128", Type::getPPC_FP128Ty(Context));
  TYPEKEYWORD("label",     Type::getLabelTy(Context));
  TYPEKEYWORD("metadata",  Type::getMetadataTy(Context));
  TYPEKEYWORD("x86_mmx",   Type::getX86_MMXTy(Context));
  TYPEKEYWORD("token",     Type::getTokenTy(Context));
*/

// NOTE: MetadataType has been removed from Type and is instead used directly
// for metadata values.

Type
	: VoidType
	/// Types '(' ArgTypeListI ')' OptFuncAttrs
	| FuncType
	| FirstClassType
;

FirstClassType
	: ConcreteType
	| MetadataType
;

ConcreteType
	: IntType
	// Type ::= 'float' | 'void' (etc)
	| FloatType
	// Type ::= Type '*'
	// Type ::= Type 'addrspace' '(' uint32 ')' '*'
	| PointerType
	// Type ::= '<' ... '>'
	| VectorType
	| LabelType
	// Type ::= '[' ... ']'
	| ArrayType
	// Type ::= StructType
	| StructType
	// Type ::= %foo
	// Type ::= %4
	| NamedType
	| MMXType
	| TokenType
;

VoidType
	: "void"
;

FloatType
	: "half"
	| "float"
	| "double"
	| "x86_fp80"
	| "fp128"
	| "ppc_fp128"
;

LabelType
	: "label"
;

MetadataType
	: "metadata"
;

MMXType
	: "x86_mmx"
;

TokenType
	: "token"
;

IntType
	: int_type
;

/*
/// ParseStructType: Handles packed and unpacked types.  </> parsed elsewhere.
///   StructType
///     ::= '{' '}'
///     ::= '{' Type (',' Type)* '}'
///     ::= '<' '{' '}' '>'
///     ::= '<' '{' Type (',' Type)* '}' '>'
bool LLParser::ParseStructBody(SmallVectorImpl<Type*> &Body) {
*/

// TODO: Clean up when the parser generator no longer introduces ambiguities
// through the limitation of 1 token lookahead.
//
// Structured in this way to allow for naiive 1 token lookahead parser
// generators.
//
// Original production rule.
//
//    StructType
//       : "{" Fields "}"
//       | "<" "{" Fields "}" ">"
//    ;
//
//    Fields
//       : empty
//       | FieldList
//    ;

StructType
	: "{" "}"
	| "{" FieldList "}"
	| "<" "{" "}" ">"
	| "<" "{" FieldList "}" ">"
;

FieldList
	: Field
	| FieldList "," Field
;

Field
	: Type
;

/*
/// ParseArrayVectorType - Parse an array or vector type, assuming the first
/// token has already been consumed.
///   Type
///     ::= '[' APSINTVAL 'x' Types ']'
///     ::= '<' APSINTVAL 'x' Types '>'
bool LLParser::ParseArrayVectorType(Type *&Result, bool isVector) {
*/

ArrayType
	: "[" int_lit "x" Type "]"
;

VectorType
	: "<" int_lit "x" Type ">"
;

NamedType
	: LocalIdent
;

PointerType
	: Type OptAddrSpace "*"
;

/*
/// ParseFunctionType
///  ::= Type ArgumentList OptionalAttrs
bool LLParser::ParseFunctionType(Type *&Result) {
*/

FuncType
	: Type "(" Args ")"
;

/*
/// ParseArgumentList - Parse the argument list for a function type or function
/// prototype.
///   ::= '(' ArgTypeListI ')'
/// ArgTypeListI
///   ::= empty
///   ::= '...'
///   ::= ArgTypeList ',' '...'
///   ::= ArgType (',' ArgType)*
///
bool LLParser::ParseArgumentList(SmallVectorImpl<ArgInfo> &ArgList,
*/

Args
	: empty
	| "..."
	| ArgList
	| ArgList "," "..."
;

ArgList
	: Arg
	| ArgList "," Arg
;

Arg
	: Type ParamAttrs
;

