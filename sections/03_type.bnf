//===----------------------------------------------------------------------===//
// Type Parsing.
//===----------------------------------------------------------------------===//

/*
/// ParseType - Parse a type.
bool LLParser::ParseType(Type *&Result, const Twine &Msg, bool AllowVoid) {
*/

/*
  TYPEKEYWORD("void",      Type::getVoidTy(Context));
  TYPEKEYWORD("half",      Type::getHalfTy(Context));
  TYPEKEYWORD("float",     Type::getFloatTy(Context));
  TYPEKEYWORD("double",    Type::getDoubleTy(Context));
  TYPEKEYWORD("x86_fp80",  Type::getX86_FP80Ty(Context));
  TYPEKEYWORD("fp128",     Type::getFP128Ty(Context));
  TYPEKEYWORD("ppc_fp128", Type::getPPC_FP128Ty(Context));
  TYPEKEYWORD("label",     Type::getLabelTy(Context));
  TYPEKEYWORD("metadata",  Type::getMetadataTy(Context));
  TYPEKEYWORD("x86_mmx",   Type::getX86_MMXTy(Context));
  TYPEKEYWORD("token",     Type::getTokenTy(Context));
*/

Type
	// Type ::= 'float' | 'void' (etc)
	: "void"
	| "half"
	| "float"
	| "double"
	| "x86_fp80"
	| "fp128"
	| "ppc_fp128"
	| "label"
	| "metadata"
	| "x86_mmx"
	| "token"
	// Type ::= StructType
	| StructType
	// Type ::= '[' ... ']'
	| ArrayType
	// Type ::= '<' ... '>'
	| VectorType
	// Type ::= %foo
	// Type ::= %4
	| NamedType
	// Type ::= Type '*'
	// Type ::= Type 'addrspace' '(' uint32 ')' '*'
	| PointerType
	/// Types '(' ArgTypeListI ')' OptFuncAttrs
	| FuncType
;

/*
/// ParseStructType: Handles packed and unpacked types.  </> parsed elsewhere.
///   StructType
///     ::= '{' '}'
///     ::= '{' Type (',' Type)* '}'
///     ::= '<' '{' '}' '>'
///     ::= '<' '{' Type (',' Type)* '}' '>'
bool LLParser::ParseStructBody(SmallVectorImpl<Type*> &Body) {
*/

StructType
	: "<" "{" Fields "}" ">"
	| "{" Fields "}"
;

Fields
	: empty
	| FieldList
;

FieldList
	: Field
	| FieldList "," Field
;

Field
	: Type
;

/*
/// ParseArrayVectorType - Parse an array or vector type, assuming the first
/// token has already been consumed.
///   Type
///     ::= '[' APSINTVAL 'x' Types ']'
///     ::= '<' APSINTVAL 'x' Types '>'
bool LLParser::ParseArrayVectorType(Type *&Result, bool isVector) {
*/

ArrayType
	: "[" int_lit "x" Type "]"
;

VectorType
	: "<" int_lit "x" Type ">"
;

NamedType
	: LocalIdent
;

PointerType
	: Type OptAddrSpace "*"
;

/*
/// ParseFunctionType
///  ::= Type ArgumentList OptionalAttrs
bool LLParser::ParseFunctionType(Type *&Result) {
*/

FuncType
	: Type "(" Args ")"
;

/*
/// ParseArgumentList - Parse the argument list for a function type or function
/// prototype.
///   ::= '(' ArgTypeListI ')'
/// ArgTypeListI
///   ::= empty
///   ::= '...'
///   ::= ArgTypeList ',' '...'
///   ::= ArgType (',' ArgType)*
///
bool LLParser::ParseArgumentList(SmallVectorImpl<ArgInfo> &ArgList,
*/

Args
	: empty
	| "..."
	| ArgList
	| ArgList "," "..."
;

ArgList
	: Arg
	| ArgList "," Arg
;

Arg
	: Type ParamAttrs
;

/*
/// ParseOptionalParamAttrs - Parse a potentially empty list of parameter attributes.
bool LLParser::ParseOptionalParamAttrs(AttrBuilder &B) {
*/

ParamAttrs
	: empty
	| ParamAttrList
;

ParamAttrList
	: ParamAttr
	| ParamAttrList ParamAttr
;

/*
/// ParseOptionalDerefAttrBytes
///   ::= empty
///   ::= AttrKind '(' 4 ')'
///
/// where AttrKind is either 'dereferenceable' or 'dereferenceable_or_null'.
bool LLParser::ParseOptionalDerefAttrBytes(lltok::Kind AttrKind,
*/

ParamAttr
	: string_lit
	| Alignment
	| "byval"
	| "dereferenceable" "(" int_lit ")"
	| "dereferenceable_or_null" "(" int_lit ")"
	| "inalloca"
	| "inreg"
	| "nest"
	| "noalias"
	| "nocapture"
	| "nonnull"
	| "readnone"
	| "readonly"
	| "returned"
	| "signext"
	| "sret"
	| "swifterror"
	| "swiftself"
	| "writeonly"
	| "zeroext"
;

