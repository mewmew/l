// ### [ Helper productions ] ##################################################

// ___ [ Function Attribute ] __________________________________________________

// ref: ParseFnAttributeValuePairs
//
//   ::= <attr> | <attr> '=' <value>

FuncAttrs
	: empty
	<< ([]ast.FuncAttribute)(nil), nil >>
	| FuncAttrList
;

FuncAttrList
	: FuncAttr
	<< []ast.FuncAttribute{$0.(ast.FuncAttribute)}, nil >>
	| FuncAttrList FuncAttr
	<< append($0.([]ast.FuncAttribute), $1.(ast.FuncAttribute)), nil >>
;

FuncAttr
	// not used in attribute groups.
	: AttrGroupID
	// used in attribute groups.
	| "align" "=" int_lit               << &ast.Alignment{Align: astx.Int($2)}, nil >>
	| "alignstack" "=" int_lit          << &ast.StackAlignment{Align: astx.Int($2)}, nil >>
	// used in functions.
	| Alignment
	| AllocSize
	| StackAlignment
	| StringLit                         << &ast.FuncAttrString{Value: $0.(string)}, nil >>
	| StringLit "=" StringLit           << &ast.FuncAttrPair{Key: $0.(string), Value: $2.(string)}, nil >>
	| "alwaysinline"                    << ast.FuncAttrAlwaysInline, nil >>
	| "argmemonly"                      << ast.FuncAttrArgMemOnly, nil >>
	| "builtin"                         << ast.FuncAttrBuiltin, nil >>
	| "cold"                            << ast.FuncAttrCold, nil >>
	| "convergent"                      << ast.FuncAttrConvergent, nil >>
	| "inaccessiblemem_or_argmemonly"   << ast.FuncAttrInaccessibleMemOrArgMemOnly, nil >>
	| "inaccessiblememonly"             << ast.FuncAttrInaccessibleMemOnly, nil >>
	| "inlinehint"                      << ast.FuncAttrInlineHint, nil >>
	| "jumptable"                       << ast.FuncAttrJumpTable, nil >>
	| "minsize"                         << ast.FuncAttrMinSize, nil >>
	| "naked"                           << ast.FuncAttrNaked, nil >>
	| "nobuiltin"                       << ast.FuncAttrNoBuiltin, nil >>
	| "noduplicate"                     << ast.FuncAttrNoDuplicate, nil >>
	| "noimplicitfloat"                 << ast.FuncAttrNoImplicitFloat, nil >>
	| "noinline"                        << ast.FuncAttrNoInline, nil >>
	| "nonlazybind"                     << ast.FuncAttrNonLazyBind, nil >>
	| "norecurse"                       << ast.FuncAttrNoRecurse, nil >>
	| "noredzone"                       << ast.FuncAttrNoRedZone, nil >>
	| "noreturn"                        << ast.FuncAttrNoReturn, nil >>
	| "nounwind"                        << ast.FuncAttrNoUnwind, nil >>
	| "optnone"                         << ast.FuncAttrOptNone, nil >>
	| "optsize"                         << ast.FuncAttrOptSize, nil >>
	| "readnone"                        << ast.FuncAttrReadNone, nil >>
	| "readonly"                        << ast.FuncAttrReadOnly, nil >>
	| "returns_twice"                   << ast.FuncAttrReturnsTwice, nil >>
	| "safestack"                       << ast.FuncAttrSafeStack, nil >>
	| "sanitize_address"                << ast.FuncAttrSanitizeAddress, nil >>
	| "sanitize_hwaddress"              << ast.FuncAttrSanitizeHWAddress, nil >>
	| "sanitize_memory"                 << ast.FuncAttrSanitizeMemory, nil >>
	| "sanitize_thread"                 << ast.FuncAttrSanitizeThread, nil >>
	| "speculatable"                    << ast.FuncAttrSpeculatable, nil >>
	| "ssp"                             << ast.FuncAttrSSP, nil >>
	| "sspreq"                          << ast.FuncAttrSSPReq, nil >>
	| "sspstrong"                       << ast.FuncAttrSSPStrong, nil >>
	| "strictfp"                        << ast.FuncAttrStrictFP, nil >>
	| "uwtable"                         << ast.FuncAttrUwtable, nil >>
	| "writeonly"                       << ast.FuncAttrWriteOnly, nil >>
;

// ___ [ Return Attribute ] __________________________________________________

// ref: ParseOptionalReturnAttrs

ReturnAttrs
	: empty
	<< ([]ast.ReturnAttribute)(nil), nil >>
	| ReturnAttrList
;

ReturnAttrList
	: ReturnAttr
	<< []ast.ReturnAttribute{$0.(ast.ReturnAttribute)}, nil >>
	| ReturnAttrList ReturnAttr
	<< append($0.([]ast.ReturnAttribute), $1.(ast.ReturnAttribute)), nil >>
;

ReturnAttr
	: Alignment
	| Dereferenceable
	| StringLit         << &ast.ReturnAttrString{Value: $0.(string)}, nil >>
	| "inreg"           << ast.ReturnAttrInReg, nil >>
	| "noalias"         << ast.ReturnAttrNoAlias, nil >>
	| "nonnull"         << ast.ReturnAttrNonNull, nil >>
	| "signext"         << ast.ReturnAttrSignExt, nil >>
	| "zeroext"         << ast.ReturnAttrZeroExt, nil >>
;

// ___ [ Parameter Attribute ] _________________________________________________

// ref: ParseOptionalParamAttrs

ParamAttrs
	: empty
	<< ([]ast.ParamAttribute)(nil), nil >>
	| ParamAttrList
;

ParamAttrList
	: ParamAttr
	<< []ast.ParamAttribute{$0.(ast.ParamAttribute)}, nil >>
	| ParamAttrList ParamAttr
	<< append($0.([]ast.ParamAttribute), $1.(ast.ParamAttribute)), nil >>
;

// ref: ParseOptionalDerefAttrBytes
//
//   ::= empty
//   ::= AttrKind '(' 4 ')'

ParamAttr
	: Alignment
	| Dereferenceable
	| StringLit         << &ast.ParamAttrString{Value: $0.(string)}, nil >>
	| "byval"           << ast.ParamAttrByval, nil >>
	| "inalloca"        << ast.ParamAttrInAlloca, nil >>
	| "inreg"           << ast.ParamAttrInReg, nil >>
	| "nest"            << ast.ParamAttrNest, nil >>
	| "noalias"         << ast.ParamAttrNoAlias, nil >>
	| "nocapture"       << ast.ParamAttrNoCapture, nil >>
	| "nonnull"         << ast.ParamAttrNonNull, nil >>
	| "readnone"        << ast.ParamAttrReadNone, nil >>
	| "readonly"        << ast.ParamAttrReadOnly, nil >>
	| "returned"        << ast.ParamAttrReturned, nil >>
	| "signext"         << ast.ParamAttrSignExt, nil >>
	| "sret"            << ast.ParamAttrSRet, nil >>
	| "swifterror"      << ast.ParamAttrSwiftError, nil >>
	| "swiftself"       << ast.ParamAttrSwiftSelf, nil >>
	| "writeonly"       << ast.ParamAttrWriteOnly, nil >>
	| "zeroext"         << ast.ParamAttrZeroExt, nil >>
;

// ___ [ Attributes ] __________________________________________________________

// ref: ParseOptionalAddrSpace
//
//   := empty
//   := 'addrspace' '(' uint32 ')'

OptAddrSpace
	: empty
	<< ast.AddrSpace(0), nil >>
	| AddrSpace
;

AddrSpace
	: "addrspace" "(" int_lit ")"
	<< ast.AddrSpace(astx.Int($2)), nil >>
;

// ref: ParseOptionalAlignment
//
//   ::= empty
//   ::= 'align' 4

Alignment
	: "align" int_lit
	<< &ast.Alignment{Align: astx.Int($1)}, nil >>
;

// ref: parseAllocSizeArguments

AllocSize
	: "allocsize" "(" int_lit ")"
	<< &ast.AllocSize{BaseSize: astx.Int($2)}, nil >>
	| "allocsize" "(" int_lit "," int_lit ")"
	<< &ast.AllocSize{BaseSize: astx.Int($2), N: astx.Int($4)}, nil >>
;

// ref: parseOptionalComdat

OptComdat
	: empty
	<< (*ast.Comdat)(nil), nil >>
	| Comdat
;

Comdat
	: "comdat"
	<< &ast.Comdat{}, nil >>
	| "comdat" "(" ComdatName ")"
	<< &ast.Comdat{Name: $2.(*ast.ComdatName)}, nil >>
;

Dereferenceable
	: "dereferenceable" "(" int_lit ")"
	<< &ast.Dereferenceable{N: astx.Int($2)}, nil >>
	| "dereferenceable_or_null" "(" int_lit ")"
	<< &ast.Dereferenceable{N: astx.Int($2), Null: true}, nil >>
;

// https://llvm.org/docs/LangRef.html#dll-storage-classes

// ref: ParseOptionalDLLStorageClass
//
//   ::= empty
//   ::= 'dllimport'
//   ::= 'dllexport'

OptDLLStorageClass
	: empty             << ast.DLLStorageClassNone, nil >>
	| DLLStorageClass
;

DLLStorageClass
	: "dllexport"   << ast.DLLStorageClassDLLExport, nil >>
	| "dllimport"   << ast.DLLStorageClassDLLImport, nil >>
;

// https://llvm.org/docs/LangRef.html#linkage-types

// ref: ParseOptionalLinkage
//
//   ::= empty
//   ::= 'private'
//   ::= 'internal'
//   ::= 'weak'
//   ::= 'weak_odr'
//   ::= 'linkonce'
//   ::= 'linkonce_odr'
//   ::= 'available_externally'
//   ::= 'appending'
//   ::= 'common'
//   ::= 'extern_weak'
//   ::= 'external'

OptLinkage
	: empty     << ast.LinkageNone, nil >>
	| Linkage
;

Linkage
	: "appending"              << ast.LinkageAppending, nil >>
	| "available_externally"   << ast.LinkageAvailableExternally, nil >>
	| "common"                 << ast.LinkageCommon, nil >>
	| "internal"               << ast.LinkageInternal, nil >>
	| "linkonce"               << ast.LinkageLinkOnce, nil >>
	| "linkonce_odr"           << ast.LinkageLinkOnceODR, nil >>
	| "private"                << ast.LinkagePrivate, nil >>
	| "weak"                   << ast.LinkageWeak, nil >>
	| "weak_odr"               << ast.LinkageWeakODR, nil >>
;

OptExternLinkage
	: empty           << ast.LinkageNone, nil >>
	| ExternLinkage
;

ExternLinkage
	: "extern_weak"   << ast.LinkageExternWeak, nil >>
	| "external"      << ast.LinkageExternal, nil >>
;

// https://llvm.org/docs/LangRef.html#runtime-preemption-model

// ref: ParseOptionalDSOLocal

OptPreemptionSpecifier
	: empty                 << ast.PreemptionNone, nil >>
	| PreemptionSpecifier
;

PreemptionSpecifier
	: "dso_local"         << ast.PreemptionDSOLocal, nil >>
	| "dso_preemptable"   << ast.PreemptionDSOPreemptable, nil >>
;

OptSection
	: empty
	<< (*ast.Section)(nil), nil >>
	| Section
;

Section
	: "section" StringLit
	<< &ast.Section{Name: $1.(string)}, nil >>
;

// ref: ParseOptionalStackAlignment
//
//   ::= empty
//   ::= 'alignstack' '(' 4 ')'
StackAlignment
	: "alignstack" "(" int_lit ")"
	<< &ast.StackAlignment{Align: astx.Int($2)}, nil >>
;

// ref: ParseOptionalUnnamedAddr

OptUnnamedAddr
	: empty         << ast.UnnamedAddrNone, nil >>
	| UnnamedAddr
;

UnnamedAddr
	: "local_unnamed_addr"   << ast.UnnamedAddrLocalUnnamedAddr, nil >>
	| "unnamed_addr"         << ast.UnnamedAddrUnnamedAddr, nil >>
;

// https://llvm.org/docs/LangRef.html#visibility-styles

// ref: ParseOptionalVisibility
//
//   ::= empty
//   ::= 'default'
//   ::= 'hidden'
//   ::= 'protected'

OptVisibility
	: empty        << ast.VisibilityNone, nil >>
	| Visibility
;

Visibility
	: "default"     << ast.VisibilityDefault, nil >>
	| "hidden"      << ast.VisibilityHidden, nil >>
	| "protected"   << ast.VisibilityProtected, nil >>
;

// ___ [ Instruction Operands ] ________________________________________________

// ref: ParseCmpPredicate

IPred
	: "eq"    << ast.IPredEQ, nil >>
	| "ne"    << ast.IPredNE, nil >>
	| "sge"   << ast.IPredSGE, nil >>
	| "sgt"   << ast.IPredSGT, nil >>
	| "sle"   << ast.IPredSLE, nil >>
	| "slt"   << ast.IPredSLT, nil >>
	| "uge"   << ast.IPredUGE, nil >>
	| "ugt"   << ast.IPredUGT, nil >>
	| "ule"   << ast.IPredULE, nil >>
	| "ult"   << ast.IPredULT, nil >>
;

// ref: ParseCmpPredicate

FPred
	: "false"   << ast.FPredFalse, nil >>
	| "oeq"     << ast.FPredOEQ, nil >>
	| "oge"     << ast.FPredOGE, nil >>
	| "ogt"     << ast.FPredOGT, nil >>
	| "ole"     << ast.FPredOLE, nil >>
	| "olt"     << ast.FPredOLT, nil >>
	| "one"     << ast.FPredONE, nil >>
	| "ord"     << ast.FPredORD, nil >>
	| "true"    << ast.FPredTrue, nil >>
	| "ueq"     << ast.FPredUEQ, nil >>
	| "uge"     << ast.FPredUGE, nil >>
	| "ugt"     << ast.FPredUGT, nil >>
	| "ule"     << ast.FPredULE, nil >>
	| "ult"     << ast.FPredULT, nil >>
	| "une"     << ast.FPredUNE, nil >>
	| "uno"     << ast.FPredUNO, nil >>
;

OverflowFlags
	: empty
	<< ([]ast.OverflowFlag)(nil), nil >>
	| OverflowFlagList
;

OverflowFlagList
	: OverflowFlag
	<< []ast.OverflowFlag{$0.(ast.OverflowFlag)}, nil >>
	| OverflowFlagList OverflowFlag
	<< append($0.([]ast.OverflowFlag), $1.(ast.OverflowFlag)), nil >>
;

OverflowFlag
	: "nsw"   << ast.OverflowFlagNSW, nil >>
	| "nuw"   << ast.OverflowFlagNUW, nil >>
;

OptExact
	: empty     << false, nil >>
	| "exact"   << true, nil >>
;

// ref: EatFastMathFlagsIfPresent

FastMathFlags
	: empty
	<< ([]ast.FastMathFlag)(nil), nil >>
	| FastMathFlagList
;

FastMathFlagList
	: FastMathFlag
	<< []ast.FastMathFlag{$0.(ast.FastMathFlag)}, nil >>
	| FastMathFlagList FastMathFlag
	<< append($0.([]ast.FastMathFlag), $1.(ast.FastMathFlag)), nil >>
;

FastMathFlag
	: "afn"        << ast.FastMathFlagAFn, nil >>
	| "arcp"       << ast.FastMathFlagARcp, nil >>
	| "contract"   << ast.FastMathFlagContract, nil >>
	| "fast"       << ast.FastMathFlagFast, nil >>
	| "ninf"       << ast.FastMathFlagNInf, nil >>
	| "nnan"       << ast.FastMathFlagNNaN, nil >>
	| "nsz"        << ast.FastMathFlagNSZ, nil >>
	| "reassoc"    << ast.FastMathFlagReassoc, nil >>
;

OptInBounds
	: empty        << false, nil >>
	| "inbounds"   << true, nil >>
;

// ref: ParseOptionalOperandBundles
//
//    ::= empty
//    ::= '[' OperandBundle [, OperandBundle ]* ']'
//
//  OperandBundle
//    ::= bundle-tag '(' ')'
//    ::= bundle-tag '(' Type Value [, Type Value ]* ')'
//
//  bundle-tag ::= String Constant

OperandBundles
	: empty
	<< ([]*ast.OperandBundle)(nil), nil >>
	| "[" OperandBundleList "]"
	<< $1, nil >>
;

OperandBundleList
	: OperandBundle
	<< []*ast.OperandBundle{$0.(*ast.OperandBundle)}, nil >>
	| OperandBundleList OperandBundle
	<< append($0.([]*ast.OperandBundle), $1.(*ast.OperandBundle)), nil >>
;

OperandBundle
	: StringLit "(" TypeValues ")"
	<< &ast.OperandBundle{Tag: $0.(string), Inputs: $2.([]*ast.TypeValue)}, nil >>
;

OptVolatile
	: empty        << false, nil >>
	| "volatile"   << true, nil >>
;

// ref: ParseScope
//
//   ::= syncscope("singlethread" | "<target scope>")?

OptSyncScope
	: empty
	<< (*ast.SyncScope)(nil), nil >>
	| "syncscope" "(" StringLit ")"
	<< &ast.SyncScope{Scope: $2.(string)}, nil >>
;

// ref: ParseOrdering
//
//   ::= AtomicOrdering

AtomicOrdering
	: "acq_rel"     << ast.AtomicOrderingAcqRel, nil >>
	| "acquire"     << ast.AtomicOrderingAcquire, nil >>
	| "monotonic"   << ast.AtomicOrderingMonotonic, nil >>
	| "release"     << ast.AtomicOrderingRelease, nil >>
	| "seq_cst"     << ast.AtomicOrderingSeqCst, nil >>
	| "unordered"   << ast.AtomicOrderingUnordered, nil >>
;

ExceptionScope
	: NoneConst
	| LocalIdent
;

// ref: ParseIndexList
//
//    ::=  (',' uint32)+

Indices
	: empty
	<< ([]int64)(nil), nil >>
	| "," IndexList
	<< $1, nil >>
;

IndexList
	: Index
	<< []int64{$0.(int64)}, nil >>
	| IndexList "," Index
	<< append($0.([]int64), $2.(int64)), nil >>
;

Index
	: int_lit
	<< astx.Int($0), nil >>
;

TypeValues
	: empty
	<< ([]*ast.TypeValue)(nil), nil >>
	| TypeValueList
;

TypeValueList
	: TypeValue
	<< []*ast.TypeValue{$0.(*ast.TypeValue)}, nil >>
	| TypeValueList TypeValue
	<< append($0.([]*ast.TypeValue), $1.(*ast.TypeValue)), nil >>
;

CommaSepTypeValueList
	: TypeValue
	<< []*ast.TypeValue{$0.(*ast.TypeValue)}, nil >>
	| CommaSepTypeValueList "," TypeValue
	<< append($0.([]*ast.TypeValue), $2.(*ast.TypeValue)), nil >>
;

TypeValue
	: Type Value
	<< astx.TypeValue($0, $1), nil >>
;

TypeConsts
	: empty
	<< ([]*ast.TypeConst)(nil), nil >>
	| TypeConstList
;

TypeConstList
	: TypeConst
	<< []*ast.TypeConst{$0.(*ast.TypeConst)}, nil >>
	| TypeConstList "," TypeConst
	<< append($0.([]*ast.TypeConst), $2.(*ast.TypeConst)), nil >>
;

TypeConst
	: Type Constant
	<< &ast.TypeConst{Type: $0.(ast.Type), Const: $1.(ast.Constant)}, nil >>
;

// ref: ParseParameterList
//
//    ::= '(' ')'
//    ::= '(' Arg (',' Arg)* ')'
//  Arg
//    ::= Type OptionalAttributes Value OptionalAttributes

Args
	: empty
	<< ([]ast.Argument)(nil), nil >>
	| "..."
	<< ([]ast.Argument)(nil), nil >>
	| ArgList
	<< $0, nil >>
	| ArgList "," "..."
	<< $0, nil >>
;

ArgList
	: Arg
	<< []ast.Argument{$0.(ast.Argument)}, nil >>
	| ArgList "," Arg
	<< append($0.([]ast.Argument), $2.(ast.Argument)), nil >>
;

// ref: ParseMetadataAsValue
//
//  ::= metadata i32 %local
//  ::= metadata i32 @global
//  ::= metadata i32 7
//  ::= metadata !0
//  ::= metadata !{...}
//  ::= metadata !"string"

Arg
	: ConcreteType ParamAttrs Value
	<< &ast.Arg{X: astx.TypeValue($0, $2), ParamAttrs: $1.([]ast.ParamAttribute)}, nil >>
	| MetadataType Metadata
	<< &ast.MetadataValue{Metadata: $1.(ast.Metadata)}, nil >>
;

// ref: ParseExceptionArgs

ExceptionArgs
	: empty
	<< ([]ast.Argument)(nil), nil >>
	| ExceptionArgList
;

ExceptionArgList
	: ExceptionArg
	<< []ast.Argument{$0.(ast.Argument)}, nil >>
	| ExceptionArgList "," ExceptionArg
	<< append($0.([]ast.Argument), $2.(ast.Argument)), nil >>
;

ExceptionArg
	: ConcreteType Value
	<< astx.TypeValue($0, $1), nil >>
	| MetadataType Metadata
	<< &ast.MetadataValue{Metadata: $1.(ast.Metadata)}, nil >>
;

// ref: ParseArgumentList
//
//   ::= '(' ArgTypeListI ')'
//  ArgTypeListI
//   ::= empty
//   ::= '...'
//   ::= ArgTypeList ',' '...'
//   ::= ArgType (',' ArgType)*

Params
	: empty
	<< &astx.Params{}, nil >>
	| "..."
	<< &astx.Params{Variadic: true}, nil >>
	| ParamList
	<< &astx.Params{Params: $0.([]*ast.Param)}, nil >>
	| ParamList "," "..."
	<< &astx.Params{Params: $0.([]*ast.Param), Variadic: true}, nil >>
;

ParamList
	: Param
	<< []*ast.Param{$0.(*ast.Param)}, nil >>
	| ParamList "," Param
	<< append($0.([]*ast.Param), $2.(*ast.Param)), nil >>
;

Param
	: Type ParamAttrs
	<< &ast.Param{Type: $0.(ast.Type), Attrs: $1.([]ast.ParamAttribute)}, nil >>
	| Type ParamAttrs LocalIdent
	<< &ast.Param{Type: $0.(ast.Type), Name: $2.(*ast.LocalIdent), Attrs: $1.([]ast.ParamAttribute)}, nil >>
;

