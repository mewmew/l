/*
/// ParseOptionalAlignment
///   ::= empty
///   ::= 'align' 4
bool LLParser::ParseOptionalAlignment(unsigned &Alignment) {
*/

Alignment
	: "align" int_lit
;

/*
/// ParseOptionalAddrSpace
///   := empty
///   := 'addrspace' '(' uint32 ')'
bool LLParser::ParseOptionalAddrSpace(unsigned &AddrSpace) {
*/

OptAddrSpace
	: empty
	| AddrSpace
;

AddrSpace
	: "addrspace" "(" int_lit ")"
;

/*
bool LLParser::parseOptionalComdat(StringRef GlobalName, Comdat *&C) {
*/

OptComdat
	: empty
	| Comdat
;

Comdat
	: "comdat"
	| "comdat" "(" ComdatName ")"
;

/*
/// ParseIndexList - This parses the index list for an insert/extractvalue
/// instruction.  This sets AteExtraComma in the case where we eat an extra
/// comma at the end of the line and find that it is followed by metadata.
/// Clients that don't allow metadata can call the version of this function that
/// only takes one argument.
///
/// ParseIndexList
///    ::=  (',' uint32)+
///
bool LLParser::ParseIndexList(SmallVectorImpl<unsigned> &Indices,
*/

Indices
	: empty
	| "," IndexList
;

IndexList
	: Index
	| IndexList "," Index
;

Index
	: int_lit
;

/*
/// ParseCmpPredicate - Parse an integer or fp predicate, based on Kind.
bool LLParser::ParseCmpPredicate(unsigned &P, unsigned Opc) {
*/

IPred
	: "eq"
	| "ne"
	| "slt"
	| "sgt"
	| "sle"
	| "sge"
	| "ult"
	| "ugt"
	| "ule"
	| "uge"
;

FPred
	: "oeq"
	| "one"
	| "olt"
	| "ogt"
	| "ole"
	| "oge"
	| "ord"
	| "uno"
	| "ueq"
	| "une"
	| "ult"
	| "ugt"
	| "ule"
	| "uge"
	| "true"
	| "false"
;

OverflowFlags
	: empty
	| OverflowFlagList
;

OverflowFlagList
	: OverflowFlag
	| OverflowFlagList OverflowFlag
;

OverflowFlag
	: "nuw"
	| "nsw"
;

OptExact
	: empty
	| "exact"
;

/*
FastMathFlags EatFastMathFlagsIfPresent() {
*/

FastMathFlags
	: empty
	| FastMathFlagList
;

FastMathFlagList
	: FastMathFlag
	| FastMathFlagList FastMathFlag
;

FastMathFlag
	: "fast"
	| "nnan"
	| "ninf"
	| "nsz"
	| "arcp"
	| "contract"
	| "reassoc"
	| "afn"
;

OptInBounds
	: empty
	| "inbounds"
;

Elems
	: empty
	| ElemList
;

ElemList
	: Elem
	| ElemList "," Elem
;

Elem
	: Type Constant
;

// https://llvm.org/docs/LangRef.html#linkage-types

/*
/// ParseOptionalLinkage
///   ::= empty
///   ::= 'private'
///   ::= 'internal'
///   ::= 'weak'
///   ::= 'weak_odr'
///   ::= 'linkonce'
///   ::= 'linkonce_odr'
///   ::= 'available_externally'
///   ::= 'appending'
///   ::= 'common'
///   ::= 'extern_weak'
///   ::= 'external'
bool LLParser::ParseOptionalLinkage(unsigned &Res, bool &HasLinkage,
*/

OptLinkage
	: empty
	| Linkage
;

Linkage
	: "private"
	| "internal"
	| "weak"
	| "weak_odr"
	| "linkonce"
	| "linkonce_odr"
	| "available_externally"
	| "appending"
	| "common"
;

OptExternLinkage
	: empty
	| ExternLinkage
;

ExternLinkage
	: "extern_weak"
	| "external"
;

// https://llvm.org/docs/LangRef.html#runtime-preemption-model

/*
void LLParser::ParseOptionalDSOLocal(bool &DSOLocal) {
*/

OptPreemptionSpecifier
	: empty
	| PreemptionSpecifier
;

PreemptionSpecifier
	: "dso_local"
	| "dso_preemptable"
;

// https://llvm.org/docs/LangRef.html#visibility-styles

/*
/// ParseOptionalVisibility
///   ::= empty
///   ::= 'default'
///   ::= 'hidden'
///   ::= 'protected'
///
void LLParser::ParseOptionalVisibility(unsigned &Res) {
*/

OptVisibility
	: empty
	| Visibility
;

Visibility
	: "default"
	| "hidden"
	| "protected"
;

// https://llvm.org/docs/LangRef.html#dll-storage-classes

/*
/// ParseOptionalDLLStorageClass
///   ::= empty
///   ::= 'dllimport'
///   ::= 'dllexport'
///
void LLParser::ParseOptionalDLLStorageClass(unsigned &Res) {
*/

OptDLLStorageClass
	: empty
	| DLLStorageClass
;

DLLStorageClass
	: "dllimport"
	| "dllexport"
;

/*
bool LLParser::ParseOptionalUnnamedAddr(
*/

OptUnnamedAddr
	: empty
	| UnnamedAddr
;

UnnamedAddr
	: "unnamed_addr"
	| "local_unnamed_addr"
;

/*
/// ParseFnAttributeValuePairs
///   ::= <attr> | <attr> '=' <value>
bool LLParser::ParseFnAttributeValuePairs(AttrBuilder &B,
*/

FuncAttrs
	: empty
	| FuncAttrList
;

FuncAttrList
	: FuncAttr
	| FuncAttrList FuncAttr
;

FuncAttr
	: "builtin"
	| AttrGroupID // not used in attribute groups.
	| string_lit
	| "align" "=" int_lit // used in attribute groups.
	| Alignment // used in functions.
	| "alignstack" "=" int_lit
	| StackAlignment
	| AllocSize
	| "alwaysinline"
	| "argmemonly"
	| "builtin"
	| "cold"
	| "convergent"
	| "inaccessiblememonly"
	| "inaccessiblemem_or_argmemonly"
	| "inlinehint"
	| "jumptable"
	| "minsize"
	| "naked"
	| "nobuiltin"
	| "noduplicate"
	| "noimplicitfloat"
	| "noinline"
	| "nonlazybind"
	| "noredzone"
	| "noreturn"
	| "norecurse"
	| "nounwind"
	| "optnone"
	| "optsize"
	| "readnone"
	| "readonly"
	| "returns_twice"
	| "speculatable"
	| "ssp"
	| "sspreq"
	| "sspstrong"
	| "safestack"
	| "sanitize_address"
	| "sanitize_hwaddress"
	| "sanitize_thread"
	| "sanitize_memory"
	| "strictfp"
	| "uwtable"
	| "writeonly"
;

/*
/// ParseOptionalStackAlignment
///   ::= empty
///   ::= 'alignstack' '(' 4 ')'
bool LLParser::ParseOptionalStackAlignment(unsigned &Alignment) {
*/
StackAlignment
	: "alignstack" "(" int_lit ")"
;

/*
bool LLParser::parseAllocSizeArguments(unsigned &BaseSizeArg,
*/

AllocSize
	: "allocsize" "(" int_lit ")"
	| "allocsize" "(" int_lit "," int_lit ")"
;

OptSection
	: empty
	| Section
;

Section
	: "section" string_lit
;

/*
/// ParseOptionalParamAttrs - Parse a potentially empty list of parameter attributes.
bool LLParser::ParseOptionalParamAttrs(AttrBuilder &B) {
*/

ParamAttrs
	: empty
	| ParamAttrList
;

ParamAttrList
	: ParamAttr
	| ParamAttrList ParamAttr
;

/*
/// ParseOptionalDerefAttrBytes
///   ::= empty
///   ::= AttrKind '(' 4 ')'
///
/// where AttrKind is either 'dereferenceable' or 'dereferenceable_or_null'.
bool LLParser::ParseOptionalDerefAttrBytes(lltok::Kind AttrKind,
*/

ParamAttr
	: string_lit
	| Alignment
	| "byval"
	| Dereferenceable
	| "inalloca"
	| "inreg"
	| "nest"
	| "noalias"
	| "nocapture"
	| "nonnull"
	| "readnone"
	| "readonly"
	| "returned"
	| "signext"
	| "sret"
	| "swifterror"
	| "swiftself"
	| "writeonly"
	| "zeroext"
;

Dereferenceable
	: "dereferenceable" "(" int_lit ")"
	| "dereferenceable_or_null" "(" int_lit ")"
;

/*
/// ParseParameterList
///    ::= '(' ')'
///    ::= '(' Arg (',' Arg)* ')'
///  Arg
///    ::= Type OptionalAttributes Value OptionalAttributes
bool LLParser::ParseParameterList(SmallVectorImpl<ParamInfo> &ArgList,
*/
Params
	: empty
	| "..."
	| ParamList
	| ParamList "," "..."
;

ParamList
	: Param
	| ParamList "," Param
;

/*
/// ParseMetadataAsValue
///  ::= metadata i32 %local
///  ::= metadata i32 @global
///  ::= metadata i32 7
///  ::= metadata !0
///  ::= metadata !{...}
///  ::= metadata !"string"
bool LLParser::ParseMetadataAsValue(Value *&V, PerFunctionState &PFS) {
*/

Param
	: ConcreteType ParamAttrs Value
	| MetadataType Metadata
;

/*
/// ParseOptionalReturnAttrs - Parse a potentially empty list of return attributes.
bool LLParser::ParseOptionalReturnAttrs(AttrBuilder &B) {
*/

ReturnAttrs
	: empty
	| ReturnAttrList
;

ReturnAttrList
	: ReturnAttr
	| ReturnAttrList ReturnAttr
;

ReturnAttr
	: string_lit
	| Dereferenceable
	| Alignment
	| "inreg"
	| "noalias"
	| "nonnull"
	| "signext"
	| "zeroext"
;

/*
/// ParseOptionalOperandBundles
///    ::= empty
///    ::= '[' OperandBundle [, OperandBundle ]* ']'
///
/// OperandBundle
///    ::= bundle-tag '(' ')'
///    ::= bundle-tag '(' Type Value [, Type Value ]* ')'
///
/// bundle-tag ::= String Constant
bool LLParser::ParseOptionalOperandBundles(
*/

OperandBundles
	: empty
	| "[" OperandBundleList "]"
;

OperandBundleList
	: OperandBundle
	| OperandBundleList OperandBundle
;

OperandBundle
	: string_lit "(" BundleInputs ")"
;

BundleInputs
	: empty
	| BundleInputList
;

BundleInputList
	: BundleInput
	| BundleInputList BundleInput
;

BundleInput
	: Type Value
;

OptVolatile
	: empty
	| "volatile"
;

/*
/// ParseOptionalCommaAlign
///   ::=
///   ::= ',' align 4
///
/// This returns with AteExtraComma set to true if it ate an excess comma at the
/// end.
bool LLParser::ParseOptionalCommaAlign(unsigned &Alignment,
*/

OptCommaAlignment
	: empty
	| "," Alignment
;

/*
/// ParseScope
///   ::= syncscope("singlethread" | "<target scope>")?
///
/// This sets synchronization scope ID to the ID of the parsed value.
bool LLParser::ParseScope(SyncScope::ID &SSID) {
*/

OptScope
	: empty
	| "syncscope" "(" string_lit ")"
;

/*
/// ParseOrdering
///   ::= AtomicOrdering
///
/// This sets Ordering to the parsed value.
bool LLParser::ParseOrdering(AtomicOrdering &Ordering) {
*/

AtomicOrdering
	: "unordered"
	| "monotonic"
	| "acquire"
	| "release"
	| "acq_rel"
	| "seq_cst"
;

